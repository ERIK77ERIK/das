// // 1
// let a = {
//     name: "Joe",
//     phone: "838383",
//     friend: [
//         "Mike", "Jine", "Carol"
//     ]
// };

// alert(JSON.stringify(a, undefined, 20));

// // JSON.stringify ֆունկցիան բացի object-ից վերցնումա եվս երկու հատ պարամետր(արժեք)
// // երկրորդ տրվող պարամետրը պետք է լինի ֆունկցիա, որը հնարաորությունա տալիս փոխել այդ տեքստի վիճակը, դրա մասին պետք չի խոսել այսօր,(այդ պատճառով undifined կտանք երկրորդ արժեքը)
// // երրորդ պարամետրը որոշումա թե մեջի տարածքը ինչքանովա ներս գալի

// // սա հարմար բան է որպեսի երբ որ մենք JSON ստանանք եթե մենք ուզենանք debugger անենք կամ ինքներս կարդանք տեքստը որը ստացել ենք, կարող ենք ֆորմատ անենք որպեսզի տեքստը հեշտ կարդացվի




// // 2
let a = {
    name: "Joe",
    phone: 838383,
    friend: [
        "Mike", "Jine", "Carol"
    ],
    sayHi: function() {
        alert("hi");
    }
};

a.sayHi();

alert(JSON.stringify(a, undefined, 20));

// // JSON.stringify-ը միայն տեքստավորումա ինֆորմացիա, function-ի մեջ քանի որ լոգիկայա, իրան չի տեքստավորում

// // ինչ չի տեքստավորում, դե հիշեք որ JSON-ի ամենակարևոր դերը նա է որ մենք object-ից կարող ենք ստանանք տեքստ բայց հետո մենք պետքա կարողանանք այդ տեքստից հետ ստանանք object
// // եթե մեջը լինի ֆունկցիա  մի հատ այսպիսի խնդիր կարող է առաջանալ, սա խնդիրներից մեկն է


// let b = 5;

// let v = {
//     name: "Joe",
//     phone: "838383",
//     friends: [
//        "Mike", "Jina", "Carol"
//     ],
//     sayHi: function() {
//         alert(b);
//     }
// };

// // պատկերացրեք մենք ունենք let b որը 5 է ու էս ֆուկցիան կախվածություն ունի էս b-ի վրա ինչու
// // որովհետև երբ որ նա կանչվում է,  տեսնում է որ իր scope-ում b չկա բարձրանում է վերևի scope-ի վրա ու վերևի scope-ի մեջ նոր գտնումա էս b-ն ու օգտագործումա

// // այսինքն ինչ է ստացվում որ եթե json․stringify-ը function-ը տեքստաորեր և պահեր իր մեջ, մենք JSON.parse եթե անեյնք նա կաշխատեր միայն են դեպքերում երբ իր բոլոր կախվածությունները լինեյն JSON.parse-ին տված տեքստի մեջ (????)
// // այսինքն պատկերացրեք JSON.parse-ին տալիս ենք այս object-ի տեքստավորված տարբերակը ու ասում ենք սրանից ստացի object, անելուց նա չգիտի արդյոք կա(ստեղծված է) մեր իրեն տված տեքստի մեջի function-ի մեջի փոփոխականը           (կամ նա չգիտի արդյոք կա(ստեղծված է) մեր իրեն տված տեքստի մեջի function-ի մեջի function-ը,(այսինքն function-ը կարող է իր մեջ կանչի ուրիշ function-ի))

// // function-ը ինքը կոդ է որը չի փոխվում, երբ որ մենք tic tac toe խաղը աշխատացնում եինք մեր կոդը չեր փոխվում, մեր ինֆորմացիան էր փոխվում օրինակ փոխվում էր են փոփոխականը որը որոշում եր x-նա հաջորդը թե o-ը
// //  ինֆորմացիան փոխվում է, կոդը չի փոխվում քանի որ ինֆորմացիան է փոխվում նրան ենք մենք տեքստավորում, ուղղարկում պահեստ և այլն և այլն 





// // 3
// // // պահեք ձեր ինֆորմացիան առանձին object-ներում պահեք ձեր լոգիկան(function-ները) առանձին object-ներում և JSON.stringify անելուց միայն ինֆորմացիան տեքստաորեք որպեսզի հետո կարողանաք հետ կարդալ JSON.parse-ով
// let n = {
//     f: function() {

//     },
//     c: function() {

//     }
// };




// // 4
// // JSON.stringify-ով որ ստանում ենք տեքստ, դա կոնկրետ javascript-ի հետ ոչ մի կապ չունի դա ուղղակի ինֆորմացիա(տեքստ) է որը ձևաորված է այդպես, javascript-ի տեսքին բայց ուղղակի ինֆորմացիա
// // լավը այն է այս ֆորմատի որ ուրիշ լեզուներում(JAVA, C++, PYTON) կան գրադարաններ որ նույնպես կարող են ստեղծել էս տիպի object և կարդան էս տիպի object այսինքն ինչ է ստացվում որ javscript-ով գրած մի ծրագիր կարող է ինչ որ object-ներ վերածել տեքստի ուղղարկի մի հատ լրիվ ուրիշ ծրագրի որը ասենք գրվածա PYTON-ով, PYTON-ը օգտագործի ինչ որ գրադարան որը դա կկարդա և կվերածի object-ների որոնք որ PYTON-ում կան
// // այսինքն ինչ է ստացվում parse ֆունկցիան javascript-ում տալիսա javascript object-ներ ուրիշ լեզուներում ելի կա JSON.parse-ին հավասար ֆունկցիա որը տալիսա էտ լեզվի object-ներ այսինքն սա շատ հարմար ֆորմատա որ մենք ինֆորմացիա պաս տանք մի ծրագրից ուրիշ ծրագիր, կամ նույն ծրագրում save անենք(պահենք) հետո հետ կարդանք կամ բազայում գրենք հետո հետ կարդանք և այլն և այլն