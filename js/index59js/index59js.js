// // 1.
// // մենք գիտենք որ javascript-ում կա true և false արժեքներ, boolean արժեքներ
// // javascript-ում նաև կա truthy և falsy հասկացողություն 
// // truthy-ի նշանակում է true-ոտ
// // falsy-ի նշանակում է false-ոտ

// // բոլոր արժեքները javascript-ում ընկնում են էս երկու խմբակներից մեկի մեջ
// // այսինքն ցանկացած արժեք կարելի է համարել ավելի true քան թե false կամ ավելի false քան թե true



// // 2.
// // ինչպես իմանանք որ արժեքներն են ընկնում որ խմբակի մեջ հետևյալ ձևով
// // մենք պետք է ուղղակի հիշենք վեց արժեքները որոնք որ համարվում են falsy և մնացածը truthy են 

// // falsy - false, 0, "", undefined, null, NaN
// // truthy - true, "ajghj", 1, [], {}, function() {}



// // 3.
// // ինչի է սա կարևոր որովհետև truthy և falsy հասկացողությունը մենք կարող ենք օրինակ օգտագործենք if-ի մեջ 

// let a = "";

// if(a) {
//     alert("yay");
// } else {
//     alert("nooo");
// };
// // կտպի nooo
// // եթե մենք սա աշխատացնենք կստանանք nooo ինչու որովհետև քանի որ սա դատարկ է, դատարկ տեքստը ինչպես հիշում եք համարվում է falsy այսինքն ավելի false քան true, if-ը հարգում է էտ փաստը և ընդունելով a-ը և ընդունելով որ ինքը ավելի false է քան true ինքը a վերածում է boolean արժեքին այս դեպքում քանի որ falsy-ա դարձնումա false և առաջի բլոկը չի աշխատացնում այլ հակառակ դեպքն է աշխատացնում


// let b = "ehaahds";

// if(b) {
//     alert("yay");
// } else {
//     alert("nooo")
// }
// // կտպի yay



// // 4.
// // !(ոչ) գիտենք ինչա նշանակում, նշանակումա որ boolean արժեքը շուռ ենք տալիս
// // բայց ստեղ boolean չի, a-ը սովորական տեքստ է բայց ինքը մեկա ընկնումա էտ երկու խմբակի մեջ կամ ավելի true-ա քան false կամ ավելի false-ա քան true, էս պարագայում քանի որ ինքը դատարկ տեքստ չի ինքը համարվումա truthy բայց երբ որ իրեն շուռ ենք տալիս ստանում ենք false
// // այսինքն սա ! այս not օպերատորը վերադարձնումա boolean արժեք
// // և ինչպես է նա աշխատում, ինքը ուսումնասիրումա a-ին ասումա ինքը truthy-ա թե falsy-ա, էս պարագայում truthy-ա ինքը դա վերածում է boolean արժեքին(դարձնումա true) և շուռ է տալիս նրան և ստանում է իր հակառակ boolean արժեքը(այս պարագայում false)

// // եթե մենք truthy արժեքը շուռ ենք տալիս ստանում ենք false ոչ թե falsy
// // նույն ձև երբ որ մենք falsy արժեքը շուռ ենք տալիս ստանում ենք true ոչ թե truthy
// // դա շատ կարևոր է
// // այսինքն not operator-ը միշտ միչև աշխատելը նախ և առաջ truthy դարձնում է true կամ falsy-ին դարձնում է false հետո նոր իրեն շուռ է տալիս

// let a = "ehaahds";

// if(!a) {
//     alert("yay");
// } else {
//     alert("nooo")
// }
// // կտպի nooo


// // այսինքն ցանկացած արժեք որը բնականաբար կամ truthy-ա կամ falsy մենք կարող ենք վերածենք իր համապատասխան boolean տարբերակին օգտագործելով !!
// // ցանկացած truthy արժեքը !! -ով կարող ենք ստանանք true
// // ցանկացած falsy արժեքից !! -ով կարող ենք ստանանք false

// let a = "";
// let b = !a;

// alert(b);
// // կտպի true

// alert(!!a)
// // կտպի false



// // 5.
// // or(կամ)-ը ինչպես է աշխատում truthy, falsy արժեքների հետ

// // 5.1
// // հիշեցում կամ(||)-ից
// // մենք գիտենք որ սա false || true կվերադարձնի true

// let a = false || true;
// alert(a);
// // կտպի true
// / կամ
// let a = true || false;
// alert(a);
// // կտպի true

// // 5.2
// // or(կամ)-ը truthy, falsy արժեքների հետ աշխատելիս միշտ նայում է նախ և առաջ իր ձախ կողմից և ստուգում է truthy է թե ոչ

// // եթե truthy է հենց էտ արժեքը վերադարձնում է
// let a = "99" || false;
// alert(a);
// // կտպի 99

// // եթե falsy է ինքը անմիջապես իր աջ կողմի արժեքն է վերադարձնում կապ չունի աջ կողմինը truthy-ա թե falsy-ա ինքը աջ կողմինը կվերադարձնի
// let a = "" || 99;
// alert(a);
// // կտպի 99


// // հետևաբար երբ որ մենք անում ենք false || true ինքը իրականում տեսնումա որ ձախ կողմի արժեքը falsy է և վերադարձնում է աջ կողմի արժեքը և մենք ստանում ենք true 
// // նույնպես եթե մենք ունենում ենք true || false ինքը տեսնումա որ ձախ կողմի արժեքը truthy է և անմիջապես իրեն վերադարձնում է
// // նույնպես եթե մենք ունենք true || true էլի նույն ձևիա աշխատում ինքը ձախ կողմինի արժեքը ուղակի վերադարձնումա աջին չի էլ նայում


// // օրինակներ

// // այսինքն եթե հիմա անենք

// if("yay" || 99) {
//     alert("yay")
// }
// // կտպի yay
// // ||
// // \/
// if("yay") {
//     alert("yay")
// }
// // կտպի yay


// if(NaN || null) {
//     alert("yay")
// }
// // չի աշխատի
// // ||
// // \/
// if(null) {
//     alert("yay")
// }
// // չի աշխատի


// if(!(NaN || null)) {
//     alert("yay");
// }
// // կտպի yay


// let a = NaN || null || undefined || 8 || false;
// alert(a);
// // կտպի 8
// // ||
// // \/
// let a = null || undefined || 8 || false;
// alert(a);
// // կտպի 8
// // ||
// // \/
// let a = undefined || 8 || false;
// alert(a);
// // կտպի 8
// // ||
// // \/
// let a =  8 || false;
// alert(a);
// // կտպի 8
// // ||
// // \/
// let a =  8;
// alert(a);
// // կտպի 8



// // 6.
// // and(և)-ը ինչպես է աշխատում truthy, falsy արժեքների հետ
// // and(և)-ը աշխատում է truthy, falsy արժեքների հետ ճիշտ հակառակ ձևով

// // 6.1
// // հիշեցում և(||)-ից

// // մենք գիտենք որ եթե մենք անենք 

// let a = false && true;
// alert(a);
// // կտպի false

// let a = true && false;
// alert(a);
// // կտպի false


// // 6.2
// // and(և)-ը or-ի հակառակն է, այսինքն and(և)-ը truthy, falsy արժեքների հետ աշխատելիս միշտ նայում է նախ և առաջ իր ձախ կողմից և ստուգում է falsy է թե ոչ

// // եթե falsy է հենց էտ արժեքը վերադարձնում է
// let a = NaN && true;
// alert(a);
// // կտպի NaN

// // եթե truthy է ինքը անմիջապես իր աջ կողմի արժեքն է վերադարձնում կապ չունի աջ կողմինը truthy-ա թե falsy-ա ինքը աջ կողմինը կվերադարձնի
// let a = 99 && undefined;
// alert(a);
// // կտպի undefined


// // հետևաբար երբ որ մենք անում ենք false && true ինքը իրականում տեսնումա որ ձախ կողմի արժեքը falsy է և անմիջապես իրեն վերադարձնում է
// // նույնպես եթե մենք ունենում ենք true && false ինքը տեսնումա որ ձախ կողմի արժեքը truthy է և վերադարձնում է աջ կողմի արժեքը և մենք ստանում ենք false
// // նույնպես եթե մենք ունենք true && true էլի նույն ձևիա աշխատում ինքը տեսնումա որ ձախ կողմի արժեքը truthy է և վերադարձնում է աջ կողմի արժեքը և մենք ստանում ենք true


// // օրինակներ

// let a = 99 && "asdf" && true && 0 && "hi";
// alert(a);
// // կտպի 0
// // ||
// // \/
// let a = "asdf" && true && 0 && "hi";
// alert(a);
// // կտպի 0
// // ||
// // \/
// let a = true && 0 && "hi";
// alert(a);
// // կտպի 0
// // ||
// // \/
// let a = 0 && "hi";
// alert(a);
// // կտպի 0
// // ||
// // \/
// let a = 0;
// alert(a);
// // կտպի 0



// // 7.
// // or(կամ)-ի պարագայում ձախ կողմինը վերադարձնում է են ժամանակ երբ նա truthy է
// // and(և)-ի պարագայում նա վերադարձնում է ձախ կողմինը երբ որ նա falsy է
// // մնացած բոլոր դեպքերում երկուսն էլ վերադարձնում են իրանց աջ կողմի արժեքը 



// // 8.
// // and(և)-ը նաև հաճախ իրեն կոչում են պաշտպանվելու օպերատոր
// // ինչ նկատի ունենք պաշտպանելու օպերատոր

// // .1.
// // խնդիրը նրանումա որ էս foo ֆունկցիան երբեմն պիտի զգույշ լինի բա որ էս տրված a-ը իր մեջ knows չունենա, ինչ կլինի, դե էտ ժամանակ error կլինի խնդիր կառաջանա, սխալներ կառաջանան մեր կոդի մեջ

// function foo(a) {
//     alert(a.knows.name);
// }

// foo({
//     knows: {
//         name: "Mike"
//     }
// })
// // կտպի Mike

// function foo(a) {
//     alert(a.knows.name);
// }

// foo({

// })
// // TypeError: Cannot read properties of undefined (reading 'name')


// // .2.
// // որպեսզի մենք պաշտպանվենք էտ խնդրի արջև մենք կարող ենք անենք սենց մի բան

// function foo(a) {
//     const name = a && a.knows && a.knows.name;
//     alert(name);
// }
// foo({
//     knows: {
//         name: "Mike"
//     }
// })
// // կտպի Mike

// // ||
// // \/

// // եթե name-ը չլինի մենք կստանանք undefined բայց ոչ մի բան չի չարդվի
// function foo(a) {
//     const name = a && a.knows && a.knows.name;
//     alert(name);
// }
// foo({
//     knows: {
       
//     }
// })
// // կտպի undefined

// // ||
// // \/

// // եթե knows-ը չլինի էլի մեր կոդը alert կանի կստանանք undefined բայց չի չարդվի
// function foo(a) {
//     const name = a && a.knows && a.knows.name;
//     alert(name);
// }
// foo({

// })
// // կտպի undefined

// // ||
// // \/

// // եթե ոչ մի բան պաս չտանք էլի մեր կոդը կաշխատի բայց մենք ընդամենը կստանանք undefined 
// function foo(a) {
//     const name = a && a.knows && a.knows.name;
//     alert(name);
// }
// foo()
// // կտպի undefined


// // այսինքն and(և)-ով մենք կարող ենք ոնցոր ստուգենք քայլառքայլ զգուշությամբ 
// // որպեսզի հաստատենք a-ը քանի որ object-ա պետքա որ truthy լինի նենց որ իրեն վերցնում ենք իսկ հիշեք որ and(&& և) օպերատորը կվերադարձնի ձախ կողմը միայն են ժամանակ երբ որ նա falsy լինի այսինքն վերջի պարագայում քանի որ a-ը undefined-ա հենց a-ին վերադարձնում է, բայց եթե a-ը լիներ դատարկ object էտ պարագայում a-ը truthy-ա նենց որ ինքը կվերադարձնի իր աջ կողմի արժեքը a.knows-ը, քանի որ knows չկա ստեղ կլինի undefined նենց որ վերջում էտ undefined-ը կվերադարնա

// // այսինքն and(&& և)-ով մենք կարող ենք պաշտվանվենք հետևաբար հաճախ and-ին կոչում են պաշտպանվելու օպերատոր
