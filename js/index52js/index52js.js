// // 1.
// // intheritance(ժառանգություն)-ը կարևոր կոնցեպտ է object oriented programning-ի մեջ
// // երկու տարբեր մոտեցում կա intheritance(ժառանգություն)-ի
// // .1. Prototypal Inheritance(նախատիպային ժառանգություն)
// // .2. Classical Inheritance(դասական ժառանգություն)

// // Classical Inheritance(դասական ժառանգություն)-ը դա այն ժառանգություննա որը հիմնականում օգտագործվում է java-ում, C++-ում և մոտաորապես տենց մի բան կա javascript-ի մեջ 
// // իսկ Prototypal Inheritance(Նախատիպային ժառանգություն)-ը դա հիմանականում javascript-ում է շատ օգտագործվում և նաև օգտագործվում են ուրիշ լեզուներում բայց շատ տարածված չեն



// // 2. 
// // ինչ է Prototypal Inheritance(Նախատիպային ժառանգություն)-ը
// // prototypal inheritance(նախատիպային ժառանգություն)-ը հնարաորություն է տալիս որ մենք անընդհատ եթե լիքը object-ներ ունենք որոնք որ ունեն մոտաորապես նույն տեսքը նույն ֆունկցիաները նույն արժեքները անընդհատ չկրկնենք այլ ստեղծենք մի հատ object որի մեջ թող լինեն էտ ֆունկցիաները օրինակ և հետո ունենանք լիքը ուրիշ object-ներ որոնք որ ընդամենը ժառանգեն իրենից
// // javascript-ում բավականին տարածված է prototypal inheritance(նախատիպային ժառանգություն)-ը, հետևաբար արժի հասկանալ, կոնցեպտը շատ պարզ է object-ները ժառանգում են իրարից

// // .1.

// const a = {
//     name: "Joe"
// };

// const b = {
//     lastName: "Jackson"
// };

// a.__proto__ = b;

// alert(a.lastName);  // Jackson

// // այս տարoրինակ հղումը ինչ է անում դա հղում է ստեղծում a-ից դեպի b object որը հնարաորություն է տալիս a-ին ժառանգել արժեքներ b-ից
// // հիմա a.lastName-ը գնում է մտնում է a-ի մեջ ման է գալիս lastName-ին և չի գտնում, երբ չի գտնում նա անմիջապես չի վերադարձնում undefined այլ նա հետևում է այս __proto__ հղմանը դեպի հաջորդ object-ին և այդ object-ից է հարցնում իսկ կարողա դուք ունենաք lastName եթե ունի վերադարձնում է եթե չունի վերադարձնում է undefined, էս պարագայում ունի որի արժեքը Jackson է եթե մենք աշխատացնենք կտեսնենք Jackson


// // .2.
// // մենք նաև կարող ենք էլի object-ներ ստեղծել 
// // և եկեք նենց անենք որ b-ն ժառանգի c-ից (b.__proto__ = c)

// const a = {
//     name: "Joe"
// };

// const b = {
//     lastName: "Jackson"
// };

// const c = {
//     age: 19,
// };

// a.__proto__ = b;
// b.__proto__ = c;

// alert(a.age); // 19

// // ինքը նախ և առաջ կմանգա age-ի a-ի մեջ չի գտնի, proto-ով կգնա դեպի b չի գտնի, proto-ով կգնա դեպի c կգտնի և կվերադարձնի 19
// // այսինքն այսպես մենք ստեղծում ենք շղթա object-ներից որը ամեն մեկը ժառանգում է հաջորդից և այսպես շղթա ենք կարողանում ստեղծել որպեսզի արժեքները մի object-ից կարողանա ժառանգել ուրիշ object



// // .3.
// // հիմա մենք նույնպես ինչպես որ կարող ենք ժառանգենք արժեքներ նաև կարող ենք ժառանգենք ֆունկցիաներ 
// // օրինակ․

// const a = {
//     name: "Joe"
// };

// const b = {
//     lastName: "Jackson"
// };

// const c = {
//     age: 19,
//     showAge() {
//         alert(this.age);
//     }
// };

// a.__proto__ = b;
// b.__proto__ = c;

// a.showAge(); // 19

// // և հիմա նա կգնա կմտնի a-ի մեջ showAge չի գտնի, կգնա b-ի մեջ չի գտնի showAge, կգնա կմտնի c-ի մեջ կգտնի և կվերադարձնի որին մենք կկանչենք և հետևաբար կտեսնենք 19


// // 3.
// // հիմա հարց այս showAge ֆունկցիայի this-ը ինչ է 
// // հիշում եք օրենքը որ երբ որ մենք անում ենք ինչ որ object կետ ինչ որ ֆունկցիա այդ ֆունկցայի this-ը դառնումա կետի ձախ կողմի արժեքը(object-ը), երբ որ իհարկե նա սովորական ֆունկցիայա և ոչ թե arrow ֆունկցիա 
// // այսինքն ինչ է ստացվում այս this-ը իրականում քանի որ a-ով ենք կանչում a-ն է որը նշանակումա որ մենք ստեղ կարող ենք անենք օրինակ this.name անենք և աշխատացնենք և կստանանք Joe, ինչու որովհետև իրա this-ը հղվածա դեպի a object-ին
// // բա this.age-ը ոնց աշխատեց, ժառանգությունով այսինքն իրա this-ը հղված էր a object-ից բայց երբ որ մենք age ուզեցինք իրա մեջ չէր, գնաց b-ի մեջ իրա մեջ է չէր, գնաց հասավ c-ին տեսավ որ կար և վերադարձրեց 19

// // ․1.
// const a = {
//     name: "Joe"
// };
// const b = {
//     lastName: "Jackson"
// };
// const c = {
//     age: 19,
//     showAge() {
//         alert(this.name);
//     }
// };
// a.__proto__ = b;
// b.__proto__ = c;
// a.showAge(); // Joe


// // .2.
// const a = {
//     name: "Joe"
// };
// const b = {
//     lastName: "Jackson"
// };
// const c = {
//     age: 19,
//     showAge() {
//         alert(this.age);
//     }
// };
// a.__proto__ = b;
// b.__proto__ = c;
// a.showAge(); // 19


// // .3.
// // այսինքն եթե մենք ստեղ ունենանք օրինակ a{age: 99} և մենք անենք a.showAge() քանի որ իրա this-ը հղավածա դեպի այս a object-ին անմիջապես այս a-ի մեջի age-ը կվերադարձնի էլ չի շարունակի գնա հասնի c-ին որովհետև 99 արդեն կա 
// const a = {
//     age: 99,
//     name: "Joe"
// };
// const b = {
//     lastName: "Jackson"
// };
// const c = {
//     age: 19,
//     showAge() {
//         alert(this.age);
//     }
// };
// a.__proto__ = b;
// b.__proto__ = c;
// a.showAge(); // 99


// // .4.
// // մենք գիտենք որ ցանկացած object-ին մենք կարող ենք ավելացնենք ինչ որ արժեք, մենք կարող ենք անենք a.age թող լինի 99(a.age = 99), սենց մենք ավելացնում ենք այս բանալին age-ը որը դեռ չկա և ավելացնում ենք 99 որպես իր արժեքը այսինքն հիմա a-ի մեջ կլինի {name: "Joe", age: "99"}
// // այսինքն հիմա եթե անենք a.showAge() մենք կտեսնենք 99

// const a = {
//     name: "Joe"
// };
// const b = {
//     lastName: "Jackson"
// };
// const c = {
//     age: 19,
//     showAge() {
//         alert(this.age);
//     }
// };
// a.__proto__ = b;
// b.__proto__ = c;
// a.age = 99;
// a.showAge(); // 99




// // 4.
// // կա delete հասկացողությունը (delete a.age;)  
// // delete նշանակումա ջնջիր այս բանալին
// // այսինքն այլևս սրանից(delete a.age;) հետո age չի լինի a-ի մեջ
// // իսկ հիմա եթե մենք a.showAge() աշխատացնենք ինչ կտեսնենք, կտեսնենք 99 հետո 19
// // մենք ավելացրեցինք age-ը հենց a-ին և ջնջեցինք age-ը հենց a-ից, c-ի age-ը մնաց որպես 19

// const a = {
//         name: "Joe"
//     };
//     const b = {
//         lastName: "Jackson"
//     };
//     const c = {
//         age: 19,
//         showAge() {
//             alert(this.age);
//         }
// };
// a.__proto__ = b;
// b.__proto__ = c;

// a.age = 99;
// a.showAge(); // 99

// delete a.age;
// a.showAge(); // 19



// // 5.
// // երբ որ մենք ժառանգում ենք եթե մենք անենք Object.keys() կամ Object.value() a-ի վրա, մենք չենք ստանա ժառանգության արժեքները մենք կստանանք հենց են բանալիները կամ արժեքները որոնք որ կցած են a-ին   
// // Object.keys() կամ Object.values() միայն կվերադարձնի այն արժեքները կամ բանալիները որոնք որ անմիջապես էտ object-ից են կցած
// // դա կարևոր է հասկանալ

// const a = {
//     name: "Joe"
// };
// const b = {
//     lastName: "Jackson"
// };
// const c = {
//     age: 19,
//     showAge() {
//         alert(this.age);
//     }
// };

// a.__proto__ = b;
// b.__proto__ = c;

// alert(Object.keys(a));    // name
// alert(Object.values(a));  // Joe



// // 6.
// // javascript-ում ընդանրապես երբ որ մենք տեսնում ենք որևէ փոփոխական կամ որևէ անուն որը սկսում է տակի գծիկով դա նշանակում է որ մենք չպետք է ձեռք տանք դա նշանակում է որ դա տակի ներքին ինչ որ փոփոխական է որը կպած է այս object-ին բայց դա մեզ համար չէ մենք չպետքա դրան կարդանք կամ գրենք կամ որևէ բան անենք դա մեր գործը չէ 

// // այսինքն էն ինչ որ ստեղ անում ենք դա շատ վատ բանա չի կարելի տենց բան անել a.__proto__ = b;
// // բա ոնց անենք որպեսզի ավելի ճիշտ մոտեցում ցույց տանք, բա ճիշտը ոնցա ինչպես կարող ենք անենք որպեսզի a-ը ժառանգի օրինակ b-ից
// const a = {
//     name: "Joe"
// };
// const b = {
//     lastName: "Jackson"
// };
// const c = {
//     age: 19,
//     showAge() {
//         alert(this.age);
//     }
// };
// a.__proto__ = b;
// b.__proto__ = c;


// // երկու մոտեցում կա 

// // .1. առաջինը մենք կարող ենք անենք հետևյալը Object.create() և պաս տանք b
// // դա մեզ կվերադարձնի մի հատ նոր object որը տակից ունի proto հղում դեպի իրեն տված object-ը(այս դեպքում b object-ը)
// // հետևաբար մենք հիմա կարող ենք անենք օրինակ a.name = "Joe"
// // և հիմա կարող ենք alert անենք կամ a.name որը մեզ կտա Joe կամ a.lastname որը մեզ կտա "Jackson"
// const b = {
//     lastName: "Jackson"
// };
// const a = Object.create(b);
// a.name = "Joe"
// alert(a.name); // Joe
// alert(a.lastName); // Jackson

// // սա մի տարբերակն է թե ինչպես մենք կարող ենք ստեղծենք object որը ունի այդ __proto__ հղումը դեպի ուրիշ object, Object.create()-ի միջոցով
// // Object.create()-ը կստեղծի մի հատ նոր object որի տակի էտ __proto__ հղումը հղված է դեպի իրեն տված object-ը 
// // այսինքն (const a = Object.create(b)) === (a.__proto__ = b)

// // .2. երկրորդ տարբերակը մենք կարող ենք a-ի համար ստեղծել մի հատ object constructor կարող ենք անենք function A() {} որը կստեղծի մեր երկրորդ object-ին որին մենք կանենք this.name = "Joe";
// // և ինչպես գիտեք ինքը տակից երբ որ մենք սա new-ով կանչենք կանի // this = {}; // return this 
// // այսինքն եթե մենք անենք new A(); մեզ կվերադարձնի մի հատ object որի մեջ կլինի name: "Joe"

// // բայց մենք կարող ենք ասենք  A constructor ջան երբ որ դու սարքես դա դու դիր այդ այդ նոր ստեղծված object-ի __proto__ հղումը դեպի մեր ուզած object-ը անելով A.prototype = b;
// // այսինքն ինքը տակից կարելի է ասել սենց բանա անում, անումա // this.__proto__ = A.prototype //b իսկ A.prototype-ին մենք դնում ենք հղում դեպի b // A.prototype = b

// // այսինքն prototype-ին function constructor-ում վերագրում ենք են object-ը որին կհղվի էտ նոր ստեղծված object-ը այդ __proto__ -ով 

// const b = {
//     lastName: "Jackson"
// };
// function A() {
//     // this = {}
//     // this.__proto__ = A.prototype; // b
//     this.name = "Joe";
//     // return this;
// }
// A.prototype = b;

// const a = new A();

// alert(a.lastName); // Jackson

// // այսինքն մենք տեսնում ենք որ մենք կարող ենք prototypal inheritance(նախատիպային ժառանգություն)-ով այնպես անենք որպեսզի մի object-ը ուրիշ object-ից ժառանգի 



// // 7.
// // .1.
// // իսկ ոնց կարելիա սա(prototypal inheritance(նախատիպային ժառանգություն)-ը) կիրառել սա ինչով է հետաքրքիր
// // իրականում մենք արդեն սա(prototypal inheritance(նախատիպային ժառանգություն)-ը) կիրառում ենք

// // ամեն անգամ երբ դուք ստեղծում եք մի հատ նոր object(const a = {};), սա տակից նույն է ինչպես որ մենք անենք սենց const a = new Object();
// // կա մի հատ function constructor որը կոչվում է Object, որը վերադարձնում է մի հատ object
// // այսինքն սա {} նույն է ինչպես որ սա new Object();

// const a = {}; // const a = new Object();

// // .2.
// // իսկ ինչ է ստացվում երբ որ մենք գրում ենք new Object ()
// // դե մենք ստանում ենք մի հատ նոր object չէ

// // իսկ էտ Object function constructor-ը   որին կցած է իմիջայլոց keys() ֆունկցիան որը կվերադարձնի բանալիները տրված Object-ի, որին կցած է values() ֆունկցիան որը կվերադարձնի արժեքները որոնք որ կան տրված object-ի մեջ
// // ինքը նաև function constructor է որը ունի prototype
// // այսինքն ամեն անգամ մենք ստեղծում ենք մի հատ object ինքը տակից ունի __proto__ հղումը դեպի ինչ որ object 
// // ինչ կա այդ object-ի մեջ եկեք ուսումնասիրենք 
// // // այսինքն վերևի օրինակում եթե մենք A.prototype-ին չվերագրեինք b ինքը տակից(ներքին բլոկից) կաներ this.__proto__ = A.prototype; որտեղ prototype-ը մի object է որի մեջ կա լիքը հետաքրքիր ֆունկցիաներ

// const a = {}; // const a = new Object()

// function Object() {
//     // this = {}
//     // this.__proto__ = Object.prototype; 

//     // return this;
// }

// const b = Object.prototype
// debugger

// // այդ object-ի մեջ կա լիքը հետաքրքիր ֆունկցիաներ որից մեկը կոչվում է toString();


// // ․2. 1
// // ինչ է անում toString()-ը
// // toString()-ը դա ոնցոր տեքստաորում է, դարձնում է տեքստ տրված object-ը
// // այսինքն ինչ է ստացվում որ եթե մենք կանչենք a.toString();,  կվերադարձնի [object Object]

// const a = {};

// alert(a);            // [object Object]
// alert(a.toString()); // [object Object]


// // .2. 2
// // այս toString-ը որտեղից եկավ
// // դա ժառանգվեց այն object-ից որին ինքը հղված է __proto__ -ով 
// // այսինքն ամեն անգամ մենք ստեղծում ենք մի հատ նոր դատարկ object իրականում նա ամբողջովին դատարկ չէ, ինքը դատարկ է բայց ինքը ունի __proto__ հղում մի հատ ուրիշ object, որը իր մեջ ունի լիքը տարբեր բաներ որից մեկը toString() ֆունկցիան է, որը գիտի տեքստաորել իրեն,տեքստի վիճակի բերել

// function Object() {
//     // this = {}
//     // this.__proto__ = Object.prototype; 
    
//     // return this;
// };
// const a = new Object(); // const a = {};


// // .2. 3
// // երբ է այս toString()-ը օգտագործվում 

// const a = {};
// alert(a + " this is fun"); 
// // կտպի [object Object] this is fun

// // երբ որ մենք սենց անենք javascript engine-ը են ինչ որ աշխատացնում է մեր կոդը սա տեսնում է ասում է սա a-ը object է, object-ին մենք պետք է դարձնենք տեքստ, բա ոնցա ինքը որոշում ոնց դարձնի տեքստ տրված object-ը ինքը իր toString()-ն է տակից կանչում ավտոմատ
// // հետևաբար եթե մենք սենց անենք կտեսնենք նույն toString()-ի արդյունքը
// // այսինքն toString()-ը դա մի ֆունկցիա է որը բոլոր object-ները ժառանգում են prototype object-ից (իրան չենք ստեղծում, մենք ստեղծեցինք ստեղ մի հատ դատարկ object բայց էս object-ը արդեն ունի իր ներքին բլոկից __proto__ հղումով հղված դեպի prototype object, որն էլ ունի իրեն կցած տարբեր ֆունկցիաներ որից մեկը toString() ֆունկցիան է, որը ավտոմատ կանչվում է տակից)



// // .2. 4
// // փորձենք toString()-ը փոխենք

// const a = {};

// Object.prototype.toString = function() {
//     return "yay";
// };

// alert(a);
// // կտպի yay

// // հիմա եթե մենք alert() անենք a-ին, a-ը դե պետքա տեքստաորվի որպեսզի նկարվի էկրանի վրա, որպեսզի նա տեքստաորվի իր toString() ֆունկցիան պետքա կանչվի որը մենք ստեղ փոխեցինք 
// // հետևաբար եթե մենք հիմա աշխատացնենք մենք տեսնում ենք yay ոչ թե [object Object]
// // այսինքն ինչ արեցինք ստեղ prototype-ը հղում է են object-ին որին a.__proto__ հղված է(a.__proto__ = Object.prototype)

// // կարող ենք նաև ստուգենք
// const a = {};
// alert(a.__proto__ === Object.prototype);
// // կտպի true

// // այսինքն Object constructor-ին ասում ենք երբ որ object ստեղծես դու, թող իրա __proto__ հղումը լինի դեպի prototype object-ին և մենք այդ object-ի(prototype object-ի) toString()-ը փոխում ենք հետևաբար ապագայում եթե մենք աշխատացնենք a.toString() կամ որևէ ժամանակ a-ը տեքստաորվի դա կկանչի տակից այս toString() ֆունկցիան և մենք կստանանք ցանկացած բան ինչ որ մենք ուզենանք



// // 8.
// // ընդհանուր ամփոփում
// // այսինքն prototypal inheritance(նախատիպային ժառանգություն)-ը ինչովա հետաքրքիր, ինչովա լավ որ ինքը հնարաորություն է տալիս որ մենք անընդհատ եթե լիքը object-ներ ունենք որոնք որ ունեն մոտաորապես նույն տեսքը նույն ֆունկցիաները նույն արժեքները անընդհատ չկրկնենք այլ ստեղծենք մի հատ object որի մեջ թող լինեն էտ ֆունկցիաները օրինակ և հետո ունենանք լիքը ուրիշ object-ներ որոնք որ ընդամենը ժառանգեն իրենից
// // prototypal inheritance(նախատիպային ժառանգություն)-ը շատ լավ բան է շատ հարմար բան է բայց ինքը շատ հաճախ չի օգտագործվում ինքը միայն օգտագործվում է javascript-ի մեջ և էլի որոշ լեզուների մեջ որոնք որ academy-իաում են օգտագործվում բայց հիմնականում տենց proect չեք հանդիպի որ գրեք ինչ որ լեզվով որը prototype-ովա գրված բացի javascript-ից

// // բայց javascript-ում բավականին տարածված է prototypal inheritance(նախատիպային ժառանգություն)-ը, հետևաբար արժի հասկանալ, կոնցեպտը շատ պարզ է object-ները ժառանգում են իրարից
// // ոնց են ժառանգում, ամեն object-ը ունի __proto__ դեպի իր ծնողը որից ինքը ժառանգում է, որը ունի __proto__ դեպի իր ծնողը և այլն և այլն միչև վերջ, և քանի որ __proto__ հղումը տակի գծիկներով է ստեղծված և մենք իրավունք չունենք ինքնուրույն ստեղծենք այդ հղումը, մենք միայն կարող ենք ստեղծենք այդ տիպի հղում կամ
// // .1.
// // մենք միայն կարող ենք ստեղծենք այդ տիպի հղում կամ function constructor-ի միջոցով, այսինքն function constructor-ին ասում ենք օգտագործիր այս prototype-ը որպես իր այդ հղումը(this.__proto__ = Object.prototype)
// function Object() {
//     // this = {}
//     // this.__proto__ = Object.prototype; 
    
//     // return this;
// };
// const a = new Object(); // const a = {};

// // .2.
// // կամ օգտագործելով object.create() ում մենք տալիս ենք այդ object-ը ինքը ստեղծում է մի հատ նոր object որը ունի այդ __proto__ հղումը դեպի այդ տրված object-ը հետո ինչ ուզում անում ենք այդ object-ով
// const b = {
//     lastName: "Jackson"
// };
// const a = Object.create(b);
// a.name = "Joe"
// alert(a.name); // Joe
// alert(a.lastName); // Jackson



// // 9.
// // հետաքրքրության համար
// const a = {} // new Object();
// alert(a); // [object Object]
// alert(a.toString()); // [object Object]
// alert(JSON.stringify(a.toString(), undefined, 2)); // "[object Object]"
// alert(JSON.stringify(a, undefined, 2)); // {}


