<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 40</title>
    <link rel="stylesheet" href="index40js/index40js.css">


</head>

<body>

    <hr>
    <h1>
      JAVASCRIPT - Canvas 2
    </h1>
    <hr>
    <br><br>

    <a href="js39html.html" target="_blank">JS 39</a>

    <br><br>

    <h2>
      1. requestAnimationFrame() <br>
       <br>
       requestAnimationFrame(function() { <br>
       <br>
       }) <br>
       նշանակումա որ  ասում ենք բրաուզեր ջան մինչև նկարելը էկրանի վրա մի հատ կանչիր այս function-ին մենք մի քիչ գործ ունենք անելու, էտ գործը կանենք երբ որ ավարտվի էտ ֆունկցիան նոր ոնց որ կգնաս ու կնկարես էկրանի վրա
       <br>
       ????????????????????  <br>
       <br><br>

      2. clearRect(x, y, width, height)<br>
         կա մի հատ ֆունկցիա որը կոչվումա clearRect ոչ թե fillRect այլ clearReact clear(պարզ) նշանակումա ոնցոր մաքրի clear react <br>
         ինքը էլի ուղանկյունա նկարում բայց պատկերացրեք ռետինով ինքը ուղակի ջնջումա ամեն ինչ ինչ որ էտ x, y-ի լայնության և բարձրությունի մեջ է <br>
         <br><br>

      3. բրաուզերը ինչպես է աշխատում սա կարևոր դետալ է, բրաուզերը մոտաորապես ամեն վարկյանի մեջ վաթսուն անգամ ուշադրություննա դարձնում dom-ին այսինքն էտ object-ներին որը նկարագրում է html-ին ուշադրություն է դարձնում css-ին են ինչ որ նկարագրում է էտ dom-ը վերջում ոնց պետքա հայտնվի էկրանի վրա և էտ ամեն ինչը համեմատում է էկրանի իրական նկարի հետ <br>
      <br><br>

      4.մենք նաև խոսանցինք որ հիմնականում երբ որ մենք նկարում ենք էկրանի վրա միշտ արժի  ինֆորմացիան որը նկարագրում է իրավիճակը, ինչ ենք ուզում նկարենք էկրանի վրա և այլն պահել առանձին, իսկ են կոդը որը էտ ինֆորմացիան գցումա էկրանի վրա նկարումա էկրանի վրա պահել առանձին <br>
        հիմնականում ամբողջ միտքը թե ինչի ենք առաջարկում որ էս ինֆորմացիան(ինֆորմացիան որը նկարագրում է իրավիճակը) պահենք առանձին էս ինֆորմացիան(են կոդը որը էտ ինֆորմացիան գցումա էկրանի վրա նկարումա էկրանի վրա) պահենք առանձին որովհետև եթե էս ինֆորմացիան փոխվի մենք կարող ենք ընդամենը էս կոդը նորից աշխատացնենք և ոնցոր թարմացնենք են ինչ որ գտնվում է էկրանի վրա <br>
        <br><br>

      5. <br>
      const canvas = document.querySelector("canvas") <br>
      const context = canvas.getContext("2d") <br>
      <br>
      let data = { <br>
          x: 10, <br>
          y: 10, <br>
          width: 50, <br>
          height: 50, <br>
          fillStyle: "red" <br>
      } <br>
      <br>
      function draw() { <br>
          context.clearRect(0, 0, canvas.width, canvas.height) <br>
          context.fillStyle = "red" <br>
          context.fillRect(data.x, data.y, data.width, data.height) <br>
      } <br>
      <br>
      let xDelta = 5 <br>
      let yDelta = 2 <br>
      <br>
      function update() { <br>
          if(data.x + data.width > canvas.width || data.x < 0) { <br>
              xDelta *= -1 <br>
          } <br>
          if(data.y + data.height > canvas.height || data.y < 0) { <br>
              yDelta *= -1 <br>
          } <br>
          <br>
          data.x += xDelta <br>
          data.y += yDelta <br>
      } <br>
      <br>
      function loop() { <br>
          requestAnimationFrame(loop) <br>
          <br>
          update() <br>
          draw() <br>
      } <br>
      <br>
      loop() <br>
      <br>
      այսինքն ինչ է ստացվում հիմա ամեն ցիկլի ժամանակ մինչև նկարելը էկրանի վրա բրաուզերը կանչում է էս loop-ը, էս loop-ում մենք ստեղծում ենք հաջորդ խնդրանքը բրաուզերի բայց հաջորդ անգամ որ նկարես էլի ինձ մի հատ կանչի դա անում ենք այստեղ հետո կանչում ենք update թարմացնել այսպես ասած որպեսզի ինֆորմացիան թարմացնենք հիմիկվա իրավիճակից ելնելով և draw ենք կանչում որպեսզի canvas-ի վրա նկարենք մեր կտավի վրա նկարենք և երբ որ մենք ավարտում ենք բրաուզերը այդ կտավը կարդալով էտ ինֆորմացիան վերածումա պիքսելների և գցումա էկրանի վրա  <br>
      <br><br>

      <canvas width="500" height="300" class="aa"></canvas>


       
    </h2>


    <script src="index40js/index40js.js"></script>
</body>

</html>



