<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 49</title>
    <link rel="stylesheet" href="index49js.css">

</head>

<body>

    <hr>
    <h1>
        JAVASCRIPT - Փակումներ(Closures)
    </h1>
    <hr>
    <br><br>

    <a href="../index48js/js48html.html" target="_blank">JS 48</a>

    <br><br>

    <h2>
        1. <br>
        նախ և առաջ պետք է վեր հիշենք փոփոխականների հասանելիություն օրենքները, scope(տեսադաշտ)-ի օրենքները <br>
        let-ով ստեղծված փոփոխականին կարող եք օգտագործել միայն իրան ստեղծելու պահից հետո և միայն իրան կարող եք օգտագործել նույն block scope-ի մեջ այսինքն իրա սահմանում <br>
        <br>
        1.1 <br>
        alert(x);  // error <br>
        let x = 5; <br>
        <br><br>

        1.2 <br>
        let x = 5; <br>
        <br>
        if(x === 5) { <br>
            alert(y);  // error <br>
            <br>
            let y = 7; <br>
            alert(x + y); // 12 <br>
            <br>
        } <br>
        alert(y)  // error <br>
        <br><br>

        1.3 <br>
        let x = 5; <br>
        <br>
        if(x === 5) { <br>
            alert(y);  // error <br>
            <br>
            let y = 7; <br>
            let x = 2; <br>
            alert(x + y); // 9 <br>
            <br>
        } <br>
        alert(y)  // error <br>
        alert(x)  // 5 <br>
        <br>
        y-ը եթե փորձենք կարդանք կասի տենց բան գոյություն չունի որովհետև y-ը ստեղծվածա ներքին blok-ի մեջ <br>
        իսկ մենք կարող ենք կարդանք փոփոխականները որոնք որ մեր blok-ում ունենք կամ մեր blok-ից վերև <br>
        <br><br>

        1.4 <br>
        let x = 5; <br>
        <br>
        let f = function() { <br>
            let y = 7; <br>
            alert(y + x);  // 12 <br>
        }; <br>
        <br>
        alert(y); // error <br>
        <br><br>


        2. <br>
        2.1 <br>
        <br>
        let x = 5; <br>
        <br>
        let f = function() { <br>
            let y = 7; <br>
            alert(x + y); <br>
        }; <br>
        <br>
        f() <br>
        <br>
        եթե հիշում եք ֆունկցիան արժեքա որին մենք վերագրել ենք f-ի մեջ ու հիմա մենք f-ին կարող ենք օրինակ կանչենք էտ f-ին կարող ենք փոխանցենք որպես ինչ-որ արժեք ուրիշ ֆունկցիաին, ինքը արժեքա <br>
        բայց էս արժեքը բացի նրանից որ իր մեջ ունի կոդ որը աշխատումա ինքը ունի կախվածություն դրսի x-ի վրա <br>
        ինքը հերիք չի որ ինքը ինքնուրույն մի հատ ֆունկցիայա որը ունի մարմին մեջը ինչ որ կոդ ինչ որ alert-ա անում ինչ որ y ունի ինքը նաև x-ի հղում ունի որը իրենից դուրս է գտնվում իր մեջ չի ստեղծված x-ը հետևաբար այդ ֆունկցիան հերիք չի որ ինքը իր ներքին լոգիկան ունի պետք է հիշի հղումները դրսի փոփոխականների <br>
        <br>
        այսինքն <br>
        <br>
        ֆունկցիան և էտ հղումները դրսի փոփոխականներին ամբողջը միասին կոչվում են Closures(փակումներ) <br>
        <br><br>


        2.2 <br>
        debugger-ով ուսումնասիրեք <br>
        որտեղ որ գրված է watch գրեք ֆունկցիայի անունը և ուսումնասիրեք <br>
        <br>
        let x = 5; <br>
        <br>
        let f = function() { <br>
            let y = 7; <br>
            alert(x + y); <br>
        }; <br>
        <br>
        debugger; <br>
        <br><br>

        հիմա եթե էս ֆունկցիաին ուսամնասիրենք մեջը լիքը խառը դետալներ կան որը ոնցոր այդ ծրագիրը որը աշխատացնում է մեր կոդը այսպես ասած javascript execution engine(javascript կատարման շարժիչ)-ը են ինչ որ աշխատացնում է մեր javascript-ը լիքը տարբեր բաներ է իրեն կպցնում իրա համար իրականում որը իքը հիշի որ ինքը հասկանա հիմնականում ինչ է կատարվում  <br>
        բայց կարճ ասած նայեք թե ինչ կա կցած f()-ին եթե մենք մտնենք scopes-ի մեջ հետո script-ի մեջ տեսնում եք իրեն կցած է այ էս x-ը որը 5 է այսինքն նաև լիքը ուրիշ բաներ բայց այ էս x-ը որը 5 է կցած է ֆունկցիաին ինքը մենակ ֆունկցիա չի որը ասումա էս ես ֆունկցիան եմ էս իմ կոդնա էս հերիքա, չէ, ինքը բացի նրանից որը ինքը առանջին ֆունկցիա է իրեն պետք է կցած լինի հղումը դեպի են դրսի փոփոխականի որպեսզի նա կարողանա աշխատել <br>
        <br><br>

        3. <br>
        3.1 <br>
        let f = function() { <br>
            return 1 <br>
        } <br>
        f()  // 1 <br>
        <br><br>

        3.2 <br>
        let f = function() { <br>
            return function() { <br>
                alert("hi"); <br>
            }; <br>
        }; <br>
        <br>
        let f2 = f(); //   function() { alert("hi"); }; <br>
        <br>
        f2();  // hi <br>
        <br><br>

        3.3 <br>
        let y = 9; <br>
        <br>
        let f = function() { <br>
            let x = 8; <br>
            let x2 = 99; <br>
            // alert(x)  // 8 <br>
            // // y = 5; <br>
            // // alert(y);  // 5 <br>
            return function() { <br>
                let z = 2; <br>
                // // y = 6; <br>
                // // alert(x + y + z)  // 8 + 6 + 2 // 16 <br>
                alert(x + y + z)  // 8 + 20 + 2 // 30 <br>
            }; <br>
        }; <br>
        <br>
        // alert(x) // error <br>
        <br>
        let f2 = f(); //   function() {  let z = 2; alert(x + y + z)  // 8 + 9 + 2 // 19 }; <br>
        <br>
        y = 20; <br>
        f2();  // hi <br>
        <br><br>

        այսինքն ինչ է ստացվում որ են պահին երբ նա աշխատում է էտ պահից նա օգտագործում է փոփոխականները իսկ փոփոխականները էտ պահին ինչ որ արժեք որ ունեն էտ արժեքնել կօգտագործվեն <br>
        <br>
        // // // ոչ թե աշխատելու պահից վերև է ընտրում փոփոխակաների արժեքները այլ աշխատելու պահից է ֆունկցիան օգտագործում փոփոխականերին իսկ իրենց արժեքը ընտրում է ֆունկցիան որտեղից որ ստեղծված է այդտեղից փոփոխականների օրենքներին համապատասխան(let-ով ստեղծված փոփոխականին կարողեք օգտագործել միայն իրան ստեղծելու պահից հետո և միայն իրան կարողեք օգտագործել նույն block scope-ի մեջ այսինքն իրա սահմանում, այսինքն եթե իր block-ի scope-ի մեջ հայտարարված չի ինքը մանա գալիս մի հատ բարձր սահմանում) էտ պահին ինչ որ արժեք որ ունեն <br>
        վերևի օրինակում կտպի 5 հետո 16 <br>
        /* <br>
        1. <br>
        let y  = 10; <br>
        <br>
        function aa() { <br>
            alert(y); <br>
        } <br>
        y = 20; <br>
        <br>
        aa();  // կտպի 20 <br>
        <br><br>

        2. <br>
        let y  = 10; <br>
        <br>
        function aa() { <br>
            y = 5; <br>
            alert(y); <br>
        } <br>
        y = 20; <br>
        <br>
        aa();  // կտպի 5 <br>
        */ <br>

        <br>
        debugger; <br>
        <br>

        ինքը միայն հիշում է հղումները դեպի էն փոփոխականներին որոնք որ իրան պետք են որոնք որ ինքը օգտագործում է այսինքն եթե ստեղծենք փոփոխական ու իրեն չօգտագործենք ինքը չի հիշի  օրնակ let x2 = 99; <br>
        <br><br>

        // ???? // f-ը scopes-ի մեջի script-ի մեջա y-ի  y: 20 հղումը պահում, f2-ուն scopes-ի մեջի script-ի մեջա y-ի  y: 20 հղումը պահում իսկ x-ի  x: 8 հղումը scopes-ի մեջի  closure-ի մեջա պահում <br>

        <br><br>

        4. <br>
        closures-ը դա ինչ է դա ֆունկցիա է որը նաև իր հետ փաթեթաորված ունի հղումներ դեպի բոլոր են դրսի փոփոխականները որ ինքը իր ներքին իր մեջ օգտագործում է, այդ ամենը միասին կոչվում է closures(փակումներ) <br>
        <br><br><br>




        <hr>
        Javascript - Վարժություն (Closures) <br>
        <hr>
        <br><br>

        վարժություն 1 <br>
        Ի՞նչ կցուցադրի <br>
        <br>
        let x = 7; <br>
        <br>
        function a(y) { <br>
            return x + y;  // 7 + 4 // 11 <br>
        } <br>
        <br>
        function b(z) { <br>
            let x = 99; <br>
            return z(4); // 11 <br>
        } <br>
        <br>
        alert(b(a)); // 11 <br>
        <br><br>

        // // // ոչ թե աշխատելու պահից վերև է ընտրում փոփոխակաների արժեքները այլ աշխատելու պահից է ֆունկցիան օգտագործում փոփոխականերին իսկ իրենց արժեքը ընտրում է ֆունկցիան որտեղից որ ստեղծված է այդտեղից փոփոխականների օրենքներին համապատասխան(let-ով ստեղծված փոփոխականին կարողեք օգտագործել միայն իրան ստեղծելու պահից հետո և միայն իրան կարողեք օգտագործել նույն block scope-ի մեջ այսինքն իրա սահմանում, այսինքն եթե իր block-ի scope-ի մեջ հայտարարված չի ինքը մանա գալիս մի հատ բարձր սահմանում) էտ պահին ինչ որ արժեք որ ունեն <br>
        վերևի օրինակում կտպի 5 հետո 16 <br>
        /* <br>
        1. <br>
        let y  = 10; <br>
        <br>
        function aa() { <br>
            alert(y); <br>
        } <br>
        y = 20; <br>
        <br>
        aa();  // կտպի 20 <br>
        <br><br>

        2. <br>
        let y  = 10; <br>
        <br>
        function aa() { <br>
            y = 5; <br>
            alert(y); <br>
        } <br>
        y = 20; <br>
        <br>
        aa();  // կտպի 5 <br>
        */ <br>
        <br><br><br>



        վարժություն 2 <br>
        Ի՞նչ կցուցադրի <br>
        <br>
        function a(x) { <br>
            return (y) => x + y; <br>
        } <br>
        <br>
        alert(a(2)(4));   // 6 <br>
        <br><br><br>



        վարժություն 3 <br>
        Ի՞նչ կցուցադրի <br>
        <br>
        function a(x) { <br>
            return function(y) { <br>
                return function(z) { <br>
                    return x + y + z; <br>
                }; <br>
            }; <br>
        } <br>
        <br>
        alert(a);             // function a(x) { function(y) {return function(z) { return x + y + z; }; }; }<br>
        alert(a(2));          // function(y) {return function(z) { return x + y + z; }; };<br>
        alert(a(2)(4));       // function(z) { return x + y + z; }; <br>
        alert(a(2)(4)(9));    // 15 <br>
        <br><br><br>



        վարժություն 4 <br>
        Ի՞նչ կցուցադրի <br>
        <br>
        function Cat() { <br>
            // this = {} <br>
            <br>
            let numLives = 7; <br>
            let name = "Jack"; <br>
            <br>
            this.age = 5; <br>
            this.getName = () => { <br>
                return name; <br>
            }; <br>
            <br>
            // this.setName = (str) => { <br>
            //     if(typeof(str) === "string") { <br>
            //         name = str; <br>
            //     } <br>
            // }; <br>
            <br>
            this.getAge = () => { <br>
                return this.age; <br>
            }; <br>
            this.catDies = () => { <br>
                numLives--; <br>
            }; <br>
            this.isDead = () => { <br>
                return numLives <= 0; <br>
            }; <br>
            <br>
            // return this <br>
        }; <br>
        <br>
        let a = new Cat(); <br>
        <br>
        a.catDies(); <br>
        a.catDies(); <br>
        a.catDies(); <br>
        a.catDies(); <br>
        alert(a.isDead());   // false <br>
        a.catDies(); <br>
        a.catDies(); <br>
        a.catDies(); <br>
        alert(a.isDead());   // true <br>
        alert(a.getName());  // Jack <br>
        a.age = 99; <br>
        alert(a.age);   // 99 <br>
        <br><br>
        a.name = []; <br>
        եթե name-կցած լիներ object-ին այսինքն ֆունկցիայի մեջ "Jack"-ը մենք վերագրեյնք this.name-ի մեջ մենք կկարողանայնք դսից փոխել օրինակ անել a.name և վերագրել ինչ որ արժեք <br>
        հետևաբար եթե սենց անենք name-ը չի փոխի որովհետև name-ը կցած չի object-ին name-ը առանձին փոփոխական է ուղղակի որը closure-ի միջոցով նենցա անում որպեսզի ինքը հասանելի լինի այս ֆունկցիաների մարմնի մեջից <br>
        այսինքն մենք getName-ով և setName-ով կարողանում ենք խաղալ այս անունի հետ բայց ոչ անմիջապես չենք կարող ուղղակի ասենք .name ու ինչ որ բան անենք 


   
    </h2>


    <script src="index49js.js"></script>
</body>

</html>




