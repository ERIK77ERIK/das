<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 53</title>
    <link rel="stylesheet" href="index53js/index53js.css">
</head>

<body>

    <hr>
    <h1>

        JAVASCRIPT OOP - object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում) -- &nbsp; &nbsp; Դասական ժառանգություն (Classical Inheritance)

    </h1>
    <hr>
    <br><br>

    <a href="js52html.html" target="_blank">JS 52</a>

    <br><br>

    <h2>
        1. <br>
        prototypal inheritance(նախատիպային ժառանգություն) ժամանակ object-ները ժառանգում են իրարից <br>
        classical inheritance(դասական ժառանգություն) ժամանակ մենք ունենք շաբլոններ որոնք որ նկարագրում են մեր object-ներին, շաբլոնները ժառանգում են իրարից և մենք այդ շաբլոններից կարող ենք ստեղծենք object-ներ, այդ շաբլոնները կոչվում են classic <br>
        <br><br>

        2. <br>
        ինչպես կարելիա ստեղծել class <br>
        գրում ենք class իր անունը սկիզբ և վերջ class Dog {} <br>
        այս շաբլոնը մենք կարող ենք օգտագործենք որպեսզի ստեղծենք object (new Dog()), նույնպես ինչպես որ մենք օգտագործում ենք function constructor-ները <br>
        դա կվերադարձնի մի հատ նոր object  <br>
        class Dog { <br>
            // this = {} <br>
        <br>
            // return this <br>
        } <br>
        const dog1 = new Dog(); <br>
        alert(dog1); // [object Object] <br>
        alert(JSON.stringify(dog1, undefined, 2)); // {} <br>
        քանի որ մեր շաբլոնը դատարկ է սա կվերադարձնի մի հատ դատարկ object <br>
        <br>

        /* <br>
        function Dog() { <br>
            // thsi = {} <br>
        <br>
            // return this <br>
        } <br>
        const dog1 = new Dog(); <br>
        alert(dog1); // [object Object] <br>
        alert(JSON.stringify(dog1, undefined, 2)); // {} <br>
        */ <br>
        <br><br>

        3. <br>
        այս շաբլոնի մեջ այսինքն class-ի մեջ մենք կարող ենք ավելացնենք ֆունկցիաներ և արժեքներ <br>
        սա ինչա նշանակումա որ եթե հիմա էս շաբլոնով կամ էս class-ով մենք ստեղծենք նոր object այդ object-ը կունենա մեր ավելացրած ֆունկցիաները և արժեքները <br>
        այսինքն հիմա մենք կարող ենք անենք օրինակ dog1.talk() <br>
        class Dog { <br>
            // this = {} <br>
            baseField = "base field" <br>
            talk() { <br>
                alert("woof"); <br>
            } <br>
            toString() { <br>
                return "dog"; <br>
            } <br>
            // return this <br>
        } <br>
        <br>
        const dog1 = new Dog(); <br>
        <br>
        dog1.talk(); // woof <br>
        alert(dog1.baseField); // base field <br>
        <br>

        /* <br>
        // ի տարբերություն function constructor-ի որի մեջ մենք արժեք ավելացնում էինք this-ին որպեսզի իր ստեղծած object-ից կարողանայնք կարդայնք այդ արժեքը, շաբլոնների(class-ների) դեպքում մենք ուղղակի իր բլոկի ներսում ստեղծելով ֆունկցիա կամ արժեք(առանց this-ին կպցնելու) կարող ենք այդ արժեքը կարդալ իր ստեղծած object-ից <br>
        function Dog () { <br>
            // this = {} <br>
            this.baseField = "base field"; <br>
            this.talk = function() { <br>
                alert("woof") <br>
              } <br>
            // return this <br>
        } <br>
        <br>
        const dog1 = new Dog(); <br>
        <br>
        dog1.talk(); // woof <br>
        alert(dog1.baseField); // base field <br>
        <br>
        // //   || <br>
        // //   \/ <br>
        <br>
        class Dog { <br>
            // this = {} <br>
            baseField = "base field" <br>
            talk = function() { <br>
            alert("woof"); <br>
            } <br>
            toString = () => { <br>
            return "dog"; <br>
            } <br>
            // return this <br>
        } <br>
        <br>
        const dog1 = new Dog(); <br>
        <br>
        dog1.talk(); // woof <br>
        alert(dog1.baseField); // base field <br>
        */ <br>
        <br><br>

        4. <br>
        շաբլոնները կամ class-երը ունեն մի հատ ֆունկցիա որը կոչվում է constructor <br>
        constructor-ը դա էն ֆունկցիան է որը անմիջապես կկանչվի են պահին երբ որ մեր նոր object-ը ստեղծվի <br>
        <br>
        շատ-շատ նման է function constructor-ին իմիջայլոց <br>
        սա ինչա նշանակում <br>
        որ եթե մենք ստեղ փոխանցենք անունը շունիկի օրինակ "Hafo" դա կգնա կմտնի constructor ֆունկցիայի մեջ <br>
        և իրեն կարող ենք ստեղ օգտագործենք օրինակ կարող ենք this-ին կպցնենք name (constructor(name) { this.name = name; }),  // this-ը դա այդ նոր ստեղծված object-նա  <br>
        <br>
        class Dog { <br>
            // this = {} <br>
            constructor(name) { <br>
                this.name = name; <br>
            } <br>
            talk() { <br>
                alert(this.name + " says woof"); <br>
            } <br>
            toString() { <br>
                return "dog"; <br>
            } <br>
            // return this <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        alert(dog1.name); // Hafo <br>
        dog1.talk();      // Hafo says woof <br>
        <br>
        այսինքն ստեղ երբ որ մենք կանչում ենք new Dog(); , մենք այդ Dog շաբլոնից կամ class-ից ստեղծում ենք մի հատ object, անմիջապես դրանից հետո constructor ֆունկցիան է կանչվում որի this-ը կլինի հենց էտ object-ը և էտ նոր object-ը վերադարձնումա և վերագրում ենք dog1 փոփոխականի մեջ <br>
        այսինքն հիմա կարող ենք անենք talk() {alert(this.name + " says woof")}; <br>
        այսինքն մենք ունենք շաբլոն կամ class, որը կարող է ունենալ տարբեր ֆունկցիաներ և արժեքներ, նաև constructor որին կարելիա իհարկե փոխանցել ինչ-որ արժեք որը this-ին կարող է կպցնի տարբեր արժեքներ որոնք որ նաև հասանելի են մնացած ֆունկցիաներից, ինչու են հասանելի շատ պարզ որովհետև հիշեք որ մենք կետով ենք կանչում որը նշանակումա որ հիմա այ էս talk()-ի this-ը կլինի այս dog1 object-ը իսկ այս object-ին քանի որ կցած է name-ը հետևաբար ինքը կարողա անի this.name, մենք նաև կարող ենք ուղակի alert անենք dog1.name քանի որ ինքը կցած է հենց this-ին(ստեղծված object-ին) <br>
        <br>

        /* <br>
        // .1. constructor-ը դա էն ֆունկցիան է որը անմիջապես կկանչվի են պահին երբ որ մեր նոր object-ը ստեղծվի <br>
        // .2. ի տարբերություն function constructor-ի որից մենք արժեք ստանում էինք իր կողքի փակագիծներից, շաբլոնների(class-ների) դեպքում մենք փոխանցած արժեքը ստանում ենք constructor ֆունկցիայի կողքի փակագիծներից և այդ արժեքը կարող ենք օգտագործենք այսինքն հասանելի է միայն constructor ֆունկցիայի բլոկի ներսում <br>
        // .3. և միայն constructor ֆունցկիայի բլոկի ներսում կարող ենք ստեղծենք արժեք let-ով, const-ով, և var-ով,որը նույնպես հասանելի է միայն constructor ֆունկցիայի բլոկի ներսում <br>
        // .4. և constructor ֆունկցիայի բլոկի ներսում this-ին(this-ը հղում է դեպի էն object-ին որի մեջ ֆունկցիան աշխատում է, և հիշեք որ this-ը որոշվում է միայն այն պահին երբ մենք function-ին կանչում ենք) կցում ենք արժեք անմիջապես this. անելով ինչպես function constructor-ի մեջ իսկ class-ի բլոկի ներսում կցում ենք this-ին արժեք առանց this. անելու ուղղակի փոփոխականին վերագրում ենք արժեք, օրինակ baseField = "base field" <br>
        class Dog { <br>
            // this = {} <br>
            constructor(nam) { <br>
                const a = 9; <br>
                this.name = nam; <br>
            } <br>
            name2 = nam <br>
            name3 = name <br>
            sayA() { <br>
                alert(a) <br>
            } <br>
            talk() { <br>
                alert(this.name + " says woof"); <br>
            } <br>
            toString() { <br>
                return "dog"; <br>
            } <br>
            // return this <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        alert(dog1.name); // Hafo <br>
        // .4. <br>
        dog1.talk();       // Hafo says woof <br>
        // .3. <br>
        dog1.sayA();       // ReferenceError: a is not defined <br>
        // .2. <br>
        alert(dog1.name2); // ReferenceError: nam is not defined <br>
        alert(dog1.name3); // դատարկ, մաքուր էջ է տպում <br>
        <br>
        // // || <br>
        // // \/ <br>
        <br>
        function Dog(nam) { <br>
            // this = {} <br>
            const a = 9; <br>
            this.name = nam <br>
            this.name3 = name; <br>
            this.sayA = function() { <br>
                alert(a) <br>
            } <br>
            this.talk = function() { <br>
                alert(this.name + " says woof"); <br>
            } <br>
            this.toString = function() { <br>
                return "dog"; <br>
            } <br>
            // return this <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        alert(dog1.name);      // Hafo <br>
        // .4. <br>
        dog1.talk();           // Hafo says woof <br>
        // .3. <br>
        dog1.sayA();           // 9 <br>
        <br>
        alert(dog1.name3);     // դատարկ, մաքուր էջ է տպում <br>
        */ <br>
        <br><br>

        5. <br>
        incapsulation-ը մեզ ասում է որ մենք պետք է մեր ներքին խոհանոցը պահենք փագ, այսինքն մեր ներքին ֆունկցիաները և մեր ներքին փոփոխականները պետք է այնպես անենք որպեսզի դրսից օգտագործողները մեր object-ի այսինքն ծրագրաորողները որոնք որ օգտագործում են մեր object-ը չկարողանան մեր ներքին փոփոխականները փոխեն կամ կարդան <br>
        բայց ստեղ օրինակ պատկերացրեք էս name-ը(որը ներքին արժեքա) մենք չենք ուզում մեկը գա ու մեր name-ը փոխի և դարձնի օրինակ "kachatur", մենք չենք ուզում դա մենք ուզում ենք որ մեր name-ը միշտ լինի Hafo <br>
        այսինքն ինչպես կարելիա անել որ մենք ներքին բլոկից ղեակավարենք իրեն բայց դրսից չղեկավարեն <br>
        իրականում javascript-ում կա այդպիսի թերություն էս պահին հիմա փորձում են մցնել ինչ որ նոր բաներ լեզվի մեջ որպեսզի հնարաորություն լինի կպցնել արժեքներ object-ին որոնք որ անհասանելի են դրսից բայց էս պահին չկա տենց հնարաորություն հետևաբար մենք կարող ենք անենք այսպես _ <br>
        այսպես _ գծիկ կարող ենք ստեղծենք սա կոչվում է underscore(ընդգծել), այս տակի գծիկը կոչվում է underscore, դա ինչ արեց, իրականում ոչ մի բան մեկա հասանելիա մենք կարող ենք ասենք dog1._name = "khachatur" օրինակ փոխենք դարձնենք "khachatur" <br>
        այսինքն են փաստը որ էս գծիկը կա չի նշանակում որ ծրագրաորողը չի կարող իրեն կարդա կամ գրի բայց կա էսպիսի ոնց որ չգրված օրենք javascript-ի մեջ որ եթե մենք տեսնում ենք որևէ փոփոխական որը սկսում է underscore-ով մենք իրեն պետքա ձեռք չտանք ոչ պետք է կարդանք, ոչ պետք է փոխենք այսինքն դա սիգնալ է ոնցոր մնացած ծրագրաորողներին որ սա ձեռք մի տուր սա քո գործը չի սա իմ ներքին փոփոխականն է դու գործ չունես <br>
        նենց որ էսպիսի կոդ(dog1._name = "khachatur") ուրիշ ծրագրաորողները հիմնականում չեն անի հետևելով այդ օրենքին այսինքն տենց մենք կարող ենք պահպանենք մեր name-ը և հաստատենք որ առաջինը ոչ ոք չի փոխի նրան և երկրորդը չէն կարծի որ սա փոփոխական է որ ես կարող եմ օգտագործեմ որից կարդամ ոչ սա ներքին ոնցոր խոհանոցի մասնիկ է գործ չունեք միայն օգտագործեք էն ինչ որ գծիկով չի օրինակ talk()-ը և toString() այսինքն եթե մենք այս շաբլոնով այս class-ով ստեղծենք մի հատ object, էտ object-ը կունենա _name իրեն կցած նաև talk() և toString() բայց ծրագրաորողները որոնք որ կօգտագործեն այս object-ը միայն կօգտագործեն talk()-ը և toString-ը քանի որ name-ը սկսում է underscore-ով <br>
        <br>
        class Dog { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            talk() { <br>
                alert(this._name + " says woof"); <br>
            } <br>
            toString() { <br>
                return "dog"; <br>
            } <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        dog1._name = "Kachatur"; <br>
        dog1.talk();  // Kachatur says woof <br>
        <br><br>

        6. <br>
        հիշեցում toString()-ից(1, 2), extends(3), եթե երկու toString()-ենք ունենում առաջինը կստուգվի թե toString()-ը կա հենց էն շաբլոնում որից ինքը ստեղծվել է թե չէ եթե ունի անմիջապես դա է կանչվում եթե չունի նոր իրա ժառանգված toString()-նա կանչում(4), ինչ է super-ը, super-ը օգտագործելու երկու տարբերակները(5, 5.1, 5.2) <br>
        <br>
        .1. <br>
        հիշեցում toString()-ից <br>
        <br>
        եթե հիշում եք toString()-ը դա այն ֆունցկիան է որը ավտոմատ կկանչվի են պահին երբ որ մենք ուզենանք ցանկացած object դարձնենք տեքստ այսինքն եթե մենք alert անենք հիմա dog1 ինքը տակից դե պետք է տեքստ ստեղծի որպեսզի նկարի alert պատուհանի մեջ այսինքն ինքը տակից իրականում կկանչի toString() function-ը որը կվերադարձնի անունը որը կլինի Hafo <br>
        class Dog { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            talk() { <br>
                alert(this._name + " says woof"); <br>
            } <br>
            toString() { <br>
                return this._name; <br>
            } <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        alert(dog1);             // Hafo <br>
        alert(dog1.toString());  // Hafo <br>
        <br>

        .2. <br>
        շատ սիրուն շունիկ ստեղծեցինք այս շաբլոնով հիմա եկեք ստեղծենք կատու <br>
        դե մեզ պետք է շաբլոն որպեսզի նկարագրենք կատվին բայց դե կատուն էլ ունի անուն կատուն էլ գիտի խոսալ և կատուն էլ ունի toString()-ը նենց որ եկեք էս ամենը copy անենք և անունը փոխենք դարձնենք Cat ուղղակի ստեղ woof-ի տեղը ասումա mew, բայց քիչ թե շատ մնացածը մնում է նույն է  <br>
        հիմա մենք այս նոր class-ով կամ շաբլոնով կարող ենք ստեղծենք կատու <br>
        <br>
        class Dog { <br>
            constructor(name) { <br>
                this._name = name; <br>
            }     <br>
            talk() { <br>
                alert(this._name + " says woof"); <br>
            } <br>
            toString() { <br>
                return "dog"; <br>
            } <br>
        } <br>
        <br>
        class Cat { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            talk() { <br>
                alert(this._name + " says mew"); <br>
            } <br>
            toString() { <br>
                return this._name; <br>
            } <br>
        } <br>
        <br>
        const cat1 = new Cat("Phiso"); <br>
         <br>
        alert(cat1);  // Phiso <br>
        cat1.talk();  // Phiso says mew <br>
        <br>

        .3. <br>
        extends ինչպես կարելի է անել որ շաբլոնները,class-երը կարողանան ժառանգեն իրարից <br>
        <br>
        եթե նկատել եք այս երկու class-երը գրեթե նույն են դե միքիչ տարբերություն կա ասենք talk()-ի մեջ բայց ասենք toString()-ը նույննա constructor-ը նույննա <br>
        նայեք ինչ կարող ենք անենք <br>
        մենք չենք սիրում շատ կոդ գրել մենք չենք սիրում նույն կոդը անընդհատ կրկնել նենց որ կարելիա անել շատ խելացի բան մի հատել class ստեղծել որի անունի թող լինի Animal(կենդանի), հիմա էս constructor()-ը և toString()-ը եկեք copy անենք և փաստ անենք Animal-ի մեջ <br>
        հիմա մենք ունենք class որը ունի էտ constructor-ը և toString-ը, հիմա մենք կարող ենք ասենք Dog ես ուզում եմ որ դու ժառանգես Animal class-ից (class Dog extends Animal {}) <br>
        հիմա մենք այս constructor-ը կարող ենք ջնջենք հանենք և toString-ը ջնջենք հանենք Dog-ի մեջից, նույնը կարող ենք անենք կատվի հետ <br>
        հիմա Dog class-ը ժառանգում է Animal class-ից, ինչա նշանակում որ երբ որ մենք ստեղծենք նոր object այս Dog-ով ինքը քանի որ constructor չունի կգնա իրա ծնողի բլոկի մեջ կնայի constructor ունի, եթե ունի անմիջապես դա կօգտագործի <br>
        երբ որ մենք alert ենք անում dog1 ինքը փորձում է իրեն տեքստ դարձնել որպեսզի նկարի էկրանի վրա, ինչպես դարձնի տեքստ կանչում է իր toString() ֆունկցիան, տենցա իրեն տեքստաորում, բայց եթե object-ին տեքստաորումա toString()-ով բայց Dog-ը չունի toString() նայումա Dog-ը ումիցա ժառանգում Animal-ից գնումա Animal-ի մեջ տեսնումա կա toString() և իրեն օգտագործումա <br>
        <br>
        սա շատ հարմար բան է և սա էն ամենա կարևոր մասն է classical inheritance(Դասական ժառանգություն)-ի, որ շաբլոնները կամ class-երը կարողանում են իրարից ժառանգել հետո իրենց օգտագործելով մենք կարող ենք ստեղծենք նոր object-ներ <br>
        <br>
        class Animal { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            toString() { <br>
                return this._name; <br>
            } <br>
        } <br>
        <br>
        class Dog extends Animal { <br>
            talk() { <br>
                alert(this._name + " says woof"); <br>
            } <br>
        } <br>
        <br>
        class Cat extends Animal { <br>
            talk() { <br>
                alert(this._name + " says mew"); <br>
            } <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        dog1.talk(); // Hafo says woof <br>
        alert(dog1); // Hafo <br>
        <br>

        .4. <br>
        եթե մենք ստեղծում ենք dog1 Dog շաբլոնով և կանչում ենք toString() առաջին հերթին կստուգվի թե toString()-ը կա հենց էն շաբլոնում որից ինքը ստեղծվել է թե չէ այսինքն նայում ենք Dog շաբլոնի մեջ եթե ունի անմիջապես դա է կանչվում եթե չունի նոր իրա ժառանգված toString()-նա կանչում  <br>
        <br>
        class Animal { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            toString() { <br>
                return this._name; <br>
            } <br>
        } <br>
        <br>
        class Dog extends Animal { <br>
            talk() { <br>
                alert(this._name + " says woof"); <br>
            } <br>
            toString() { <br>
                return "Dog"; <br>
            } <br>
        } <br>
        <br>
        class Cat extends Animal { <br>
            talk() { <br>
                alert(this._name + " says mew"); <br>
            } <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        dog1.talk(); // Hafo says woof <br>
        alert(dog1.toString()); // Dog <br>
        <br>

        .5. <br>
        ինչ է super-ը <br>
        <br>
        պատկերացրեք մենք մեր toString()-ի մեջ ուզում ենք նաև կանչենք ծնողի toString()-ը այսինքն ժառանգված toString()-ը <br>
        ինչպես դա կարելիա անել <br>
        super նշանակում է իմ ծնող շաբլոնը իմ ծնող class-ը <br>
        այսինքն սա ինչ է ասում սա ասումա երբ որ իմ toString()-ը կանչվի ես կվերադարձնեմ մի հատ տեքստ որը կլինի "Dog named " որին ես կկպցնեմ էս գործողությունի(super.toString()) արդյունքը <br>
        իսկ էս գործողությունը super.toString() ինչ է ասում <br>
        super նշանակումա իմ ծնողը այսինքն էն շաբլոնը ումից ես ժառանգում եմ  .toString() <br>
        այսինքն սա ինչա ստացվում որ կասի էս իմ toString()-ը չի այլ են շաբլոնի toString()-նա ումից ես ժառանգում եմ որ ես չլինեյ էտ կլիներ այ էտ ում ես ուզում եմ կանչեմ հետևաբար կգնա վերև ու կասի ինչ toString() էինք մենք ժառանգում եթե էս մեկը չլիներ հետևաբար super.toString()-ը կկանչի toString() { return this._name} <br>
        <br>
        super-ը օգտագործվում է երկու ձևով մեկը սա է <br>
        .5.1 ինչպես է օգտագործվում super-ը <br>
        class Animal { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            toString() { <br>
                return this._name; <br>
            } <br>
        } <br>
        <br>
        class Dog extends Animal { <br>
            talk() { <br>
                alert(this._name + " says woof - " + this.toString()); <br>
            } <br>
            toString() { <br>
                return "Dog named " + super.toString(); <br>
            } <br>
        } <br>
        <br>
        class Cat extends Animal { <br>
            talk() { <br>
                alert(this._name + " says mew"); <br>
            } <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo"); <br>
        <br>
        dog1.talk(); // Hafo says woof - Dog named Hafo <br>
        alert(dog1.toString()); // Dog named Hafo <br>
        <br>

        .5.2 ինչպես է օգտագործվում super-ը <br>
        պատկերացրեք մենք ուզում ենք ունենանք մեր սեփական constructor-ը <br>
        մենք կարող ենք սենց անենք բայց էս ժամանակ քանի որ ծնողն է ունի constructor մենք անպայման պետք է նաև ծնող constructor-ին կանչենք <br>
        անպայման և դա հիմնականում պետք է անել հենց առաջի տողում մեր constructor ֆունկցիայի <br>
        օրենքը նենցա որ պետք է անպայման ծնող constructor-ին կանչել միչև this-ը օգտագործելը <br>
        ինչպես ենք կանչում ծնող constructor-ին այսպես չենք անում super.constructor(); դրա տեղը ընդամենը կանչում ենք այսպես super(); <br>
        հիմա մեր ծնող constructor-ը սպասում է անուն հետևաբար մենք այս անունը(name-ը) փոխանցում ենք իրեն super(name); <br>
        հիմա ինչ է ստացվում որ մեր շունիկը ունի իր սեփական constructor-ը որը նախնական կկանչի ծնողի constructor-ին որպեսզի ինքը իր գործողությունը անի, հետո կարողա ավելորդ ինչ որ գործողություններ անի օրինակ ավելացնի նաև տարիք մեր Dog-ին որպեսզի մեր շունը բացի անունից ունենա նաև տարիք (this._age = age) <br>
        <br>
        հիմա մեր dog1-ը կունենա _name = "Hafo", _age = 18, talk() և toString() ֆունկցիաներ էսքանը պարզ է հույսովեմ <br>
        <br>
        այսինքն super-ը են հատուկ անուն է որի միջոցով մենք կարող ենք մեր շաբլոնից(class-ից) խոսալ մեր ծնող class-ի հետ <br>
        constructor-ի մեջ մենք կանչում ենք հենց super()-ին որպես ֆունկցիա որպեսզի ծնողի constructor-ին կանչենք սա անպայման է առանց դրա չի աշխատի <br>
        իսկ ուրիշ տեղերում ուրիշ սովորական ֆունկցիաներում մենք կարող ենք անենք super ու կետ ու կանչենք ինչ որ ֆունկցիա որը նշանակումա կանչիր ծնողի ֆունկցիան ոչ թե իմ local ֆունկցիան էն ֆունկցիան որ ես եմ ստեղծել իմ շաբլոնի մեջ <br>
        <br>
        class Animal { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            toString() { <br>
                return this._name; <br>
            } <br>
        } <br>
        <br>
        class Dog extends Animal { <br>
            constructor(name, age) { <br>
                super(name); <br>
                this._age = age; <br>
            } <br>
            talk() { <br>
                alert(this._name + " says woof - " + this.toString()); <br>
            } <br>
            toString() { <br>
                return "Dog named " + super.toString(); <br>
            } <br>
        } <br>
        <br>
        class Cat extends Animal { <br>
            talk() { <br>
                alert(this._name + " says mew"); <br>
            } <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo", 18); <br>
        <br>
        dog1.talk(); // Hafo says woof - Dog named Hafo <br>
        alert(dog1.toString()); // Dog named Hafo <br>
        <br><br>

        7. <br>
        Ամփոփում <br>
        <br>
        մենք հասկացանք երեք կարևոր կոնցեպտներ <br>
        .1. առաջինը որ մենք ունենք շաբլոններ(class-եր)ում մենք ստեղծում ենք շատ պարզ գրում ենք class իր անունը () {} որի մեջ էլ դնում ենք լիքը-լիքը արժեքներ երբ որ մենք ստեղծում ենք մի հատ object այդ class-ը օգտագործելով այդ object-ը ունենում է այդ արժեքները իր մեջ <br>
        constructor()-ը դա մի հատ հատուկ ֆունկցիա է որը մենք դսից չպետքա օգտագործենք ինքը ուղղակի մի ֆունկցիա է որը աշխատում է են պահին երբ որ object-ը ստեղծվում է, ինքը իր մեջ ընդունում է այն արժեքները որը մենք փոխանցում ենք են պահին երբ կանչում ենք, հետո ինքը ինչ որ գործողություննա անում օրինակ կարող է կպցնի այդ արժեքները իրեն և այլն <br>
        .2. երկրորդը այն է որ մեր շաբլոնները մեր class-երը կարող են ժառանգեն իրարից extends օգտագործելով այսինքն սա class Dog extends Animal {} նշանակումա ստեղծում ենք մի շաբլոն ում անունը Dog է որը ժառանգում է Animal շաբլոնից սա նշանակումա որ հիմա այն ֆունկցիաները որոնք որ Dog-ի մեջ չլինեն ինքը անմիջապես ուղղակի կժառանգի Animal-ից <br>
        .3. և մենք պետք է մեր constructur-ից ամպայման կանչենք մեր ծնող class-ի constructor-ին ինչպես ենք դա անում կանչելով super(name) ֆունկցիան և փոխանցելով էն ինֆորմացիան որը ծնող constructor-ը սպասում է օրինակ էս պարագայում անուն ենք փոխանցում, մենք նաև կարող ենք կանչենք ցանկացած ֆունկցիա որը կցած է մեր ծնող class-ից, այն class-ից որից մենք ժառանգում ենք super օգտագործելով այսինքն անում ենք super. և անունը էտ ֆունկցիայի որը ուզում ենք կանչենք որը մենք ժառանգում էինք ու մենք անմիջապես հենց այդ ժառանգված ֆունկցիան կարողանում ենք կանչենք այդպես <br>
        <br><br>

        8. <br>
        instanceof(օրինակ) <br>
        երբ որ մենք օգտագործում ենք Dog class-ը որպեսզի ստեղծենք dog1-ին մենք ապագայում կարող ենք ասենք այս dog1-ը, այն object-ը որը dog1-ի մեջ է այս Dog շաբլոնիցա ստեղծված թե չէ <br>
        ինչպես որ կարողանում էինք ասել function constructor-ի դեպքում <br>
        դա անում էինք այսպես dog1 instanceof Dog <br>
        <br>
        class Animal { <br>
            constructor(name) { <br>
                this._name = name; <br>
            } <br>
            toString() { <br>
                return this._name; <br>
            } <br>
        } <br>
        <br>
        class Dog extends Animal { <br>
            constructor(name, age) { <br>
                super(name); <br>
                this._age = age; <br>
            } <br>
            talk() { <br>
                alert(this._name + " says woof - " + this.toString()); <br>
            } <br>
            toString() { <br>
                return "Dog named " + super.toString(); <br>
            } <br>
        } <br>
        <br>
        class Cat extends Animal { <br>
            talk() { <br>
                alert(this._name + " says mew"); <br>
            } <br>
        } <br>
        <br>
        const dog1 = new Dog("Hafo", 18); <br>
        <br>
        alert(dog1 instanceof Dog);    // true <br>
        alert(dog1 instanceof Cat);    // false <br>
        alert(dog1 instanceof Animal); // true <br>
        այսինքն ինչ է ստացվում որ այս dog1 object-ը հերիք չի որ կարելիա ասել որ ինքը շուն է ինքը նաև կենդանի է <br>
        <br><br>

        9. <br>
        .1. ուղղակի canvas-ը (Canvas 5), <br>
        .2. canvas-ը encapsulation կոնցեպտով, <br>
        .3. canvas-ը Դասական ժառանգություն(Classical Inheritance)-ով առանց extends անելու <br>
        .4. canvas-ը Դասական ժառանգություն(Classical Inheritance)-ով extends անելով <br>
        /* <br>
            .1. 1 <br>
            հակարակորդա ձախ կողմը հասնելուց աջ կողմիցա գալիս <br>
            <br>
            .1. 2 <br>
            առանց EXTENDS անելու <br>
            որպեսզի գտնենք ավելացած կոդը <br>
            <br>
            .1. 3 <br>
            EXTENDS անելով <br>
            որպեսզի գտնենք ավելացած կոդը <br>
            <br>
            ավելացած կոդ չկա, անցնում գնումա հակարակորդը <br>
        */ <br>
        <br>

        <canvas width="500" height="300"></canvas>
        <br><br>

        պրակտիկ օրինակ <br>
        .1. <br>
        ուղղակի canvas-ը (Canvas 5) <br>
        <br>
        const canvas = document.querySelector("canvas") <br>
        const context = canvas.getContext("2d") <br>
        <br>
        const backgroundImg = document.createElement("img") <br>
        backgroundImg.src = "" <br>
        <br>
        const heroImg = document.createElement("img") <br>
        heroImg.src = "" <br>
        <br>
        const starImg = document.createElement("img") <br>
        starImg.src = "" <br>
        <br>
        const audio = document.createElement("audio") <br>
        audio.src = "http://novastar-main.co.hays.tx.us/NovaStar5/sounds/laser.wav" <br>
        <br>
        const rabbitImg = document.createElement("img") <br>
        rabbitImg.src = "" <br>
        <br>
        const stabAudio = document.createElement("audio") <br>
        stabAudio.src = "http://sistemas7.sead.ufscar.br:8080/jspui/bitstream/123456789/2261/2/duck.wav" <br>
        <br>
        let data = { <br>
            hero: { <br>
                xDelta: 0, <br>
                yDelta: 0, <br>
                x: 10, <br>
                y: 140, <br>
                width: 100, <br>
                height: 100 <br>
            }, <br>
            bullets: [], <br>
            rabbits: [] <br>
        } <br>
        <br>
        // <br>
        <br>
        function intersect(rect1, rect2) { <br>
            const x = Math.max(rect1.x, rect2.x), <br>
            num1 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width), <br>
            y = Math.max(rect1.y, rect2.y), <br>
            num2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height); <br>
            <br>
            return (num1 >= x && num2 >= y) <br>
        } <br>
        <br>
        // <br>
        <br>
        function update() { <br>
            data.hero.x += data.hero.xDelta <br>
            data.hero.y += data.hero.yDelta <br>
        <br>
        data.bullets.forEach(function(bullet) { <br>
            bullet.x += bullet.xDelta <br>
        }) <br>
        <br>
        data.bullets = data.bullets.filter(function(bullet) { <br>
            if(bullet.x > canvas.width) { <br>
                return false <br>
            } <br>
            return true <br>
        }) <br>
        <br>
        data.bullets.forEach(function(bullet) { <br>
            data.rabbits.forEach(function(rabbit) { <br>
                if(intersect(rabbit, bullet)) { <br>
                    stabAudio.currentTime = 0 <br>
                    stabAudio.play() <br>
        <br>
                    bullet.deleteMe = true <br>
                    rabbit.deleteMe = true <br>
                } <br>
            }) <br>
        }) <br>
        <br>
        data.bullets = data.bullets.filter(function(bullet) { <br>
            return bullet.deleteMe !== true <br>
        }) <br>
        data.rabbits = data.rabbits.filter(function(rabbit) { <br>
            return rabbit.deleteMe !== true <br>
        }) <br>
        <br>
        data.rabbits.forEach(function(rabbit) { <br>
            rabbit.x += rabbit.xDelta <br>
        }) <br>
        <br>
            if(data.rabbits.length === 0) { <br>
                data.rabbits.push({ <br>
                    xDelta: -1, <br>
                    x: canvas.width - 100, <br>
                    y: data.hero.y, <br>
                    width: 100, <br>
                    height: 100 <br>
                }) <br>
            } <br>
        } <br>
        <br>
        function draw() { <br>
            context.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height) <br>
            context.drawImage(heroImg, data.hero.x, data.hero.y, data.hero.width, data.hero.height) <br>
        <br>
        data.bullets.forEach(function(bullet) { <br>
            context.drawImage(starImg, bullet.x, bullet.y, bullet.width, bullet.height) <br>
        }) <br>
        <br>
            data.rabbits.forEach(function(rabbit) { <br>
                context.drawImage(rabbitImg, rabbit.x, rabbit.y, rabbit.width, rabbit.height) <br>
            }) <br>
        } <br>
        <br>
        function loop() { <br>
            requestAnimationFrame(loop) <br>
        <br>
            update() <br>
            draw() <br>
        } <br>
        loop() <br>
        <br>
        document.addEventListener("keydown", function(evt) { <br>
            if(evt.code === "ArrowRight") { <br>
                    data.hero.xDelta = 1 <br>
                } else if(evt.code === "ArrowLeft") { <br>
                    data.hero.xDelta = -1 <br>
                } else { <br>
                    audio.currentTime = 0 <br>
                    audio.play() <br>
                    data.bullets.push({ <br>
                    xDelta: 5, <br>
                    x: data.hero.x + data.hero.width, <br>
                    y: data.hero.y + data.hero.height/2, <br>
                    width: 20, <br>
                    height: 20 <br>
                }) <br>
            } <br>
        }) <br>
        <br>
        document.addEventListener("keyup", function(evt) { <br>
            data.hero.xDelta = 0 <br>
        }) <br>
        <br><br>



        .2. canvas-ը encapsulation կոնցեպտով, <br>
        <br>
        const canvas = document.querySelector("canvas"); <br>
        const context = canvas.getContext("2d"); <br>
        <br>

        function Hero(x, y, width, height) { <br>
            <br>
            const heroImg = document.createElement("img"); <br>
            heroImg.src = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwx3cRyk0JKQEKJAHw9OglG6QpBa0Hqps4qQ&usqp=CAU" <br>
            <br>
            let xDelta = 0; <br>
            let yDelta = 0; <br>
            <br>
            this.update = () => { <br>
                x += xDelta; <br>
                y += yDelta; <br>
            }; <br>
            <br>
            this.render = () => { <br>
                context.drawImage(heroImg, x, y, width, height); <br>
            }; <br>
            <br>
            this.goRight = () => { <br>
                xDelta = 1; <br>
            }; <br>
            this.goLeft = () => { <br>
                xDelta = -1; <br>
            }; <br>
            this.stop = () => { <br>
                xDelta = 0; <br>
            } <br>
            <br>
        } <br>
        <br>
        <br>
        let data = { <br>
        hero: new Hero(20, 20, 40, 40) <br>
        }; <br>
        <br>
        <br>
        function update() { <br>
            data.hero.update() <br>
        } <br>
        <br>
        function render() { <br>
            context.clearRect(0, 0, canvas.width, canvas.height); <br>
            data.hero.render() <br>
        } <br>
        <br>
        <br>
        function loop() { <br>
            requestAnimationFrame(loop); <br>
            update(); <br>
            render(); <br>
        } <br>
        <br>
        loop(); <br>
        <br>
        <br>
        <br>
        document.addEventListener("keydown", (evt) => { <br>
            if(evt.code === "ArrowRight") { <br>
                data.hero.goRight(); <br>
            } else if (evt.code === "ArrowLeft") { <br>
                data.hero.goLeft(); <br>
            } <br>
        }) <br>
        <br>
        document.addEventListener("keyup", (evt) => { <br>
            data.hero.stop(); <br>
        }); <br>
        <br><br>


        .3. canvas-ը Դասական ժառանգություն(Classical Inheritance)-ով առանց extends անելու <br>
        <br>
        const canvas = document.querySelector("canvas"); <br>
        const context = canvas.getContext("2d"); <br>
        <br>
        const backgroundImg = document.createElement("img") <br>
        backgroundImg.src = "" <br>
        <br>
        class Hero { <br>
            constructor(x, y, width, height) { <br>
                this._x = x; <br>
                this._y = y; <br>
                this._width = width; <br>
                this._height = height; <br>
                <br>
                this._speed = 1; <br>
                this._xDelta = 0; <br>
                this._yDelta = 0; <br>
                <br>
                this._img = document.createElement("img"); <br>
                this._img.src = "" <br>
                <br>
                this._audio = document.createElement("audio"); <br>
                this._audio.src = "http://novastar-main.co.hays.tx.us/NovaStar5/sounds/laser.wav"; <br>
            } <br>
            <br>
            getBoundingBox() { <br>
                return { <br>
                    x: this._x, <br>
                    y: this._y, <br>
                    width: this._width, <br>
                    height: this._height <br>
                }; <br>
            } <br>
            <br>
            update() { <br>
                this._x += this._xDelta; <br>
                this._y += this._yDelta; <br>
            } <br>
            <br>
            render() { <br>
                context.drawImage(this._img, this._x, this._y, this._width, this._height); <br>
            } <br>
            <br>
            goRight() { <br>
                this._xDelta = this._speed; <br>
            }; <br>
            <br>
            goLeft() { <br>
                this._xDelta = this._speed * -1; <br>
            }; <br>
            <br>
            stop() { <br>
                this._xDelta = 0; <br>
            } <br>
            <br>
            fire() { <br>
                const x = this._x + this._width, <br>
                y = this._y + this._height/2, <br>
                width = 20, <br>
                height = 20; <br>
                <br>
                const bullet = new Bullet(x, y, width, height); <br>
                bullet.goRight(); <br>
                data.bullets.push(bullet); <br>
                <br>
                this._audio.currentTime = 0; <br>
                this._audio.play(); <br>
            } <br>
        } <br>
        <br>

        class Rabbit { <br>
            constructor(x, y, width, height) { <br>
                this._x = x; <br>
                this._y = y; <br>
                this._width = width; <br>
                this._height = height; <br>
                <br>
                this._speed = 1; <br>
                this._xDelta = 0; <br>
                this._yDelta = 0; <br>
                <br>
                this._img = document.createElement("img"); <br>
                this._img.src = "" <br>
            } <br>
            <br>
            getBoundingBox() { <br>
                return { <br>
                    x: this._x, <br>
                    y: this._y, <br>
                    width: this._width, <br>
                    height: this._height <br>
                }; <br>
            } <br>
            <br>
            update() { <br>
                this._x += this._xDelta; <br>
                this._y += this._yDelta; <br>
                <br>
                if((this._xDelta < 0 && this._x + this._width < 0) || (this._xDelta > 0 && this._x > canvas.width)) { <br>
                    this.deleteMe = true; <br>
                } <br>
            } <br>
            <br>
            render() { <br>
                context.drawImage(this._img, this._x, this._y, this._width, this._height); <br>
            } <br>
            <br>
            goRight() { <br>
                this._xDelta = this._speed; <br>
            }; <br>
            <br>
            goLeft() { <br>
                this._xDelta = this._speed * -1; <br>
            }; <br>
            <br>
            stop() { <br>
                this._xDelta = 0; <br>
            } <br>
            <br>
            die() { <br>
                this.deleteMe = true; <br>
            } <br>
        } <br>
        <br>

        class Bullet { <br>
            constructor(x, y, width, height) { <br>
                this._x = x; <br>
                this._y = y; <br>
                this._width = width; <br>
                this._height = height; <br>
                <br>
                this._speed = 5; <br>
                this._xDelta = 0; <br>
                this._yDelta = 0; <br>
                <br>
                this._img = document.createElement("img"); <br>
                this._img.src = "" <br>
                <br>
                this._stabAudio = document.createElement("audio"); <br>
                this._stabAudio.src = "http://sistemas7.sead.ufscar.br:8080/jspui/bitstream/123456789/2261/2/duck.wav" <br>
            } <br>
            <br>
            getBoundingBox() { <br>
                return { <br>
                    x: this._x, <br>
                    y: this._y, <br>
                    width: this._width, <br>
                    height: this._height <br>
                }; <br>
            } <br>
            <br>
            update() { <br>
                this._x += this._xDelta; <br>
                this._y += this._yDelta; <br>
                <br>
                if((this._xDelta < 0 && this._x + this._width < 0) || (this._xDelta > 0 && this._x > canvas.width)) { <br>
                    this.deleteMe = true; <br>
                } <br>
                <br>
                data.rabbits.forEach((rabbit) => { <br>
                    if(intersect(this.getBoundingBox(), rabbit.getBoundingBox())) { <br>
                        rabbit.die(); <br>
                        this._stabAudio.currentTime = 0; <br>
                        this._stabAudio.play(); <br>
                        this.deleteMe = true <br>
                    } <br>
                }) <br>
            } <br>
            <br>
            render() { <br>
                context.drawImage(this._img, this._x, this._y, this._width, this._height); <br>
            } <br>
            <br>
            goRight = () => { <br>
                this._xDelta = this._speed; <br>
            }; <br>
            <br>
            goLeft = () => { <br>
                this._xDelta = this._speed * -1; <br>
            }; <br>
            <br>
            stop = () => { <br>
                this._xDelta = 0; <br>
            } <br>
        } <br>
        <br>

        let data = { <br>
            hero: new Hero(10, 140, 100, 100), <br>
            bullets: [], <br>
            rabbits: [] <br>
        } <br>
        <br>

        function intersect(rect1, rect2) { <br>
            const x = Math.max(rect1.x, rect2.x), <br>
            num1 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width), <br>
            y = Math.max(rect1.y, rect2.y), <br>
            num2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height); <br>
            <br>
            return (num1 >= x && num2 >= y) <br>
        } <br>
        <br>
        function update() { <br>
            data.hero.update() <br>
            data.bullets.forEach((bullet) => { bullet.update() }) <br>
            data.rabbits.forEach((rabbit) => { rabbit.update() }) <br>
            <br>
            data.bullets = data.bullets.filter((bullet) => bullet.deleteMe !== true) <br>
            data.rabbits = data.rabbits.filter((rabbit) => rabbit.deleteMe !== true) <br>
            <br> 
            if(data.rabbits.length === 0) { <br>
                const rabbit = new Rabbit(canvas.width, 140, 100, 100); <br>
                rabbit.goLeft(); <br>
                data.rabbits.push(rabbit); <br>
            } <br>
        } <br>
        <br>
        function render() { <br>
            context.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height) <br>
            <br>
            data.hero.render(); <br>
            data.bullets.forEach((bullet) => bullet.render()) <br>
            data.rabbits.forEach((rabbit) => rabbit.render()) <br>
        } <br>
        <br>
        function loop() { <br>
            requestAnimationFrame(loop) <br>
            <br>
        update() <br>
        render() <br>
        } <br>
        loop() <br>
        <br>

        document.addEventListener("keydown", function(evt) { <br>
            if(evt.code === "ArrowRight") { <br>
                data.hero.goRight() <br>
            } else if(evt.code === "ArrowLeft") { <br>
                data.hero.goLeft() <br>
            } else { <br>
                data.hero.fire() <br>
            } <br>
        }) <br>
        <br>

        document.addEventListener("keyup", (evt) => { <br>
            data.hero.stop(); <br>
        }); <br>
        <br><br>


        .4. <br>
        canvas-ը Դասական ժառանգություն(Classical Inheritance)-ով  <br>
        extends անելով <br>
        <br>
        const canvas = document.querySelector("canvas"); <br>
        const context = canvas.getContext("2d"); <br>
        <br>
        const backgroundImg = document.createElement("img"); <br>
        backgroundImg.src = ""; <br>
        <br>
        class GameObj { <br>
            constructor(x, y, width, height) { <br>
                this._x = x; <br>
                this._y = y; <br>
                this._width = width; <br>
                this._height = height; <br>
                <br>
                this._speed = 1; <br>
                this._xDelta = 0; <br>
                this._yDelta = 0; <br>
                <br>
                this._img = document.createElement("img"); <br>
                this._img.src = ""; <br>
            } <br>
            <br>
            getBoundingBox() { <br>
                return { <br>
                    x: this._x, <br>
                    y: this._y, <br>
                    width: this._width, <br>
                    height: this._height <br>
                }; <br>
            } <br>
            <br>
            update() { <br>
                this._x += this._xDelta; <br>
                this._y += this._yDelta; <br>
            } <br>
            render() { <br>
                context.drawImage(this._img, this._x, this._y, this._width, this._height) <br>
            } <br>
            <br>
            goRight() { <br>
                this._xDelta = this._speed; <br>
            } <br>
            goLeft() { <br>
                this._xDelta = this._speed * -1; <br>
            } <br>
            stop() { <br>
                this._xDelta = 0; <br>
            } <br>
        } <br>
        <br>

        class Hero extends GameObj { <br>
            constructor(x, y, width, height) { <br>
                super(x, y, width, height); <br>
                <br>
                this._img = document.createElement("img"); <br>
                this._img.src = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwx3cRyk0JKQEKJAHw9OglG6QpBa0Hqps4qQ&usqp=CAU" <br>
                <br>
                this._audio = document.createElement("audio"); <br>
                this._audio.src = "http://novastar-main.co.hays.tx.us/NovaStar5/sounds/laser.wav"; <br>
            } <br>
            <br>
            fire() { <br>
                const x = this._x + this._width, <br>
                y = this._y + this._height / 2, <br>
                width = 20, <br>
                height = 20; <br>
                <br>
                const bullet = new Bullet(x, y, width, height); <br>
                bullet.goRight(); <br>
                data.bullets.push(bullet); <br>
                <br>
                this._audio.currentTime = 0; <br>
                this._audio.play(); <br>
            } <br>
        } <br>
        <br>

        class Rabbit extends GameObj { <br>
            constructor(x, y, width, height) { <br>
                super(x, y, width, height); <br>
                <br>
                this._img = document.createElement("img"); <br>
                this._img.src = ""; <br>
            } <br>
            <br>
            update() { <br>
                super.update(); <br>
                <br>
                if((this._xDelta < 0 && this._x + this,this._width < 0) || (this._xDelta > 0 && this._x > canvas.width)) { <br>
                    this.deleteMe = true; <br>
                } <br>
            } <br>
            <br>
            die() { <br>
                this.deleteMe = true; <br>
            } <br>
        } <br>
        <br>

        class Bullet extends GameObj { <br>
            constructor(x, y, width, height) { <br>
                super(x, y, width, height); <br>
                <br>
                this._speed = 5; <br>
                <br>
                this._img = document.createElement("img"); <br>
                this._img.src = "" <br>
                <br>
            this._stabAudio = document.createElement("audio"); <br>
            this._stabAudio.src = "http://sistemas7.sead.ufscar.br:8080/jspui/bitstream/123456789/2261/2/duck.wav" <br>
            } <br>
            <br>
            update() { <br>
                super.update(); <br>
                <br>
                if((this._xDelta < 0 && this._x + this._width < 0) || (this._xDelta > 0 && this._x > canvas.width)) { <br>
                    this.deleteMe = true; <br>
                } <br>
                <br>
                data.rabbits.forEach((rabbit) => { <br>
                    if(intersect(this.getBoundingBox(), rabbit.getBoundingBox())) { <br>
                        rabbit.die(); <br>
                        this._stabAudio.currentTime = 0; <br>
                        this._stabAudio.play(); <br>
                        this.deleteMe = true <br>
                    } <br>
                }); <br>
            } <br>
        } <br>
        <br>

        let data = { <br>
            hero: new Hero(10, 140, 100, 100), <br>
            bullets: [], <br>
            rabbits: [] <br>
        } <br>
        <br>
        function intersect(rect1, rect2) { <br>
            const x = Math.max(rect1.x, rect2.x), <br>
            num1 = Math.min(rect1.x + rect1.width, rect2.x + rect2.width), <br>
            y = Math.max(rect1.y, rect2.y), <br>
            num2 = Math.min(rect1.y + rect1.height, rect2.y + rect2.height); <br>
            <br>
            return (num1 >= x && num2 >= y) <br>
        } <br>
        <br>
        function update() { <br>
            data.hero.update() <br>
            data.bullets.forEach( (bullet) => bullet.update() ) <br>
            data.rabbits.forEach( (rabbit) => rabbit.update() ) <br>
            <br>   
            data.bullets = data.bullets.filter((bullet) => bullet.deleteMe !== true) <br>
            data.rabbits = data.rabbits.filter((rabbit) => rabbit.deleteMe !== true) <br>
            <br>
            if(data.rabbits.length === 0) { <br>
                const rabbit = new Rabbit(canvas.width, 140, 100, 100); <br>
                rabbit.goLeft(); <br>
                data.rabbits.push(rabbit); <br>
            } <br>
        } <br>
        <br>
        function render() { <br>
            context.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height) <br>
            <br> 
            data.hero.render(); <br>
            data.bullets.forEach((bullet) => bullet.render()) <br>
            data.rabbits.forEach((rabbit) => rabbit.render()) <br>
        } <br>
        <br>
        function loop() { <br>
            requestAnimationFrame(loop) <br>
            <br>
            update() <br>
            render() <br>
        } <br>
        loop() <br>
        <br>

        document.addEventListener("keydown", function(evt) { <br>
            if(evt.code === "ArrowRight") { <br>
                data.hero.goRight() <br>
            } else if(evt.code === "ArrowLeft") { <br>
                data.hero.goLeft() <br>
            } else { <br>
                data.hero.fire() <br>
            } <br>
        }) <br>
        <br>
        document.addEventListener("keyup", (evt) => { <br>
            data.hero.stop(); <br>
        }); <br>

        <br><br>
        
        

        10. <br>
        կա երկու տիպի ժառանգություն <br>
        .1. կա Նախատիպային ժառանգություն (Prototypal Inheritance),երբ որ object-ները ժառանգում են անմիջապես իրարից <br>
        .2. և կա Դասական ժառանգություն (Classical Inheritance), որտեղ որ կան class-եր, այսինքն շաբլոններ որոնք որ ժառանգում են իրարից ոըր օգտագործելով մենք կարող ենք ստեղծենք object-ներ <br>
        <br>
        Դասական ժառանգություն (Classical Inheritance)-ը շատ տարածված է, օգտագործվում է Java-ում, C#(C-Sharp)-ում, C++ և որոշ չափի javasxript-ում <br>
        <br>
        ամպայման մի գաղտնիք պետք է ձեզ ասեմ որ իրականում չնայած կան class-եր javascript-ի մեջ, ինքը տակից սուս-փուս առանց ոչ մեկի ասելու իրականում օգտագործում է Նախատիպային ժառանգություն (Prototypal Inheritance), դա տակից բայց մենք դրան ուշադրություն չենք դարձնում, կոնցեպտն է կարևոր, կոնցեպտը նա է որ կան class էր այսինքն շաբլոններ որը օգտագործելով մենք կարող ենք ստեղծենք object-ներ և այդ շաբլոնները կարողանում են իրարից ժառանգել 

        
    </h2>


    <script src="index53js/index53js.js"></script>
</body>

</html>