<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 48</title>
    <link rel="stylesheet" href="index48js.css">
</head>

<body>

    <hr>
    <h1>
        JAVASCRIPT - սլաքով ֆունկցիաներ(arrow functions)
    </h1>   
    <hr>
    <br><br>

    <a href="../index47js/js47html.html" target="_blank">JS 47</a>

    <br><br>

    <h2>
        1. ֆունկցիա ստեղծելու տարբերակները <br>
        <br>
        1.1 <br>
        func(5) <br>
        <br>
        function func(x) { <br>
            alert(x) <br>
        } <br>
        func(5) <br>
        <br>

        1.2 <br>
        const func2 = function(x) { <br>
            alert(x) <br>
        } <br>
        func2(5) <br>
        <br>

        1.3 <br>
        const obj = { <br>
            func: function(x) { <br>
                alert(x) <br>
            } <br>
        } <br>
        obj.func(5) <br>
        <br>

        1.4 <br>
        [5, 4, 3].forEach(function(val) { <br>
            alert(val) <br>
        }) <br>
        էտ տիպի ֆունկցիաները կոչվում են unnames function(անանուն ֆունկցիա) այսինքն անուն չունեցող ֆունկցիա <br>
        <br><br>

        2. ինչ է arrow ֆունկցիան <br>
        <br>
        arrow function-ը(սլաքով ֆունկցիան) նախ և առաջ մեզ հնարաորություն է տալիս գրել կամ ստեղծել ֆունկցիա մի քիչ ավելի պարզ ձևով <br>
        <br>
        const func = function(x) { <br>
            alert(x) <br>
        } <br>
        func(3) <br>
        <br>
        ինչպես կարելի սովորական ֆունկցիան թարգմանել arrow ֆունկցիայի function-ը delete ենք անում և փակագծերի աջ կողմից ավելացնում ենք սլաք <br>
        հիմա ստեղծեցինք arrow ֆունկցիա <br>
        <br>
        const func = (x) => { <br>
            alert(x) <br>
        } <br>
        func(3) <br>
        <br>
        ինքը մոտաորապես նույն ձևիա աշխատում ինչպես որ սովորական ֆունկցիան ինչ եմ ասում մոտաորապես որովհետև իրականում տարբերություններ կան <br>
        <br><br>

        ինչպես ֆունկցիաների երեք ստեղծման տարբերակները դարձնել arrow ֆունկցիա <br>
        <br>
        const func = function(x) { <br>
            alert(x) <br>
        } <br>
        func(3) <br>
            || <br>
            \/ <br>
        const func = (x) => { <br>
            alert(x) <br>
        } <br>
        func(3) <br>
        <br><br>

        const obj = { <br>
            func: function(x) { <br>
                alert(x) <br>
            } <br>
        } <br>
        obj.func(5) <br>
            || <br>
            \/ <br>
        const obj = { <br>
            func: (x) => { <br>
                alert(x) <br>
            } <br>
        } <br>
        obj.func(5) <br>
        <br><br>

        
        [5, 4, 3].forEach(function(val) { <br>
            alert(val) <br>
        }) <br>
            || <br>
            \/ <br>
        [5, 4, 3].forEach((val) => { <br>
            alert(val) <br>
        }) <br>
        <br><br>

        3. ինչով է տարբերվում բացի տեսքից <br>
        ամենակարևոր ու ամենամեծ տարբերությունը this-ը ինչպես է օգտագործվում <br>
        <br>
        3.1 <br>
        օրինակներ որ դեպքում this-ը ինչ կլինի <br>
        <br>
        const func = function() { <br>
            alert(this) <br>
        } <br>
        func() <br>
        կտպի [object Window] <br>
        <br><br>

        const func = function() { <br>
            alert(this) <br>
        } <br>
        const obj = { <br>
            func: func <br>
        } <br>
        obj.func() <br>
        կտպի [object Object] <br>
        <br><br>
        
        const func = () => { <br>
            alert(this) <br>
        } <br>
        func() <br>
        կտպի [object Window] <br>
        <br><br>
        
        const func = () => { <br>
            alert(this) <br>
        } <br>
        const obj = { <br>
            func: func <br>
        } <br>
        obj.func() <br>
        կտպի [object Window] <br>
        <br><br>

        3.2 <br>
        ըստ են օրենքի դե գիտենք սովորական ֆունկցիան ինչպես է աշխատում այս ֆունկցիայի this-ը կընդունի կետի ձախ կողմի արժեքը ու ամեն ինչ կաշխատի <br>
        բայց կտպի [object Window] ոչ թե են object-ը այլ window <br>
        <br>
        երբ որ մենք ստեղծում ենք սովորական ֆունկցիա իրա this-ը որոշվում է են պահին երբ մենք իրեն կանչում ենք ու նայած ոնց ենք իրեն կանչում ինչ իրավիճակում և այլն էտ ժամանակ իրա this-ը որոշվում է էտ պահից <br>
        ի տարբերություն arrow ֆունկցիայի <br>
        arrow ֆունկցիան երբ որ մենք ստեղծում ենք երբ որ իրեն հայտարարում ենք հենց էտ պահին իրա this-ը որոշվում է <br>
        <br>
        իսկ իրա this-ը ինչ է ինչպես է որոշվում դե նայած ինքը որ ֆունկցիայի մեջ է ստեղծվում, ինքը էտ ֆունկցիայի this-ը ընդունում է որպես իրա this-ը <br>
        <br><br>

        3.3 <br>
        խնդիր 1 <br>
        ինչպես անենք որպեսզի func ֆունկցիայի this-ը լինի forEach-ին տված ֆունկցիայի this-ը <br>
        <br>
        const obj = { <br>
            func: function() { <br>
                [4, 5, 6].forEach(function(val) { <br>
                    alert(this) <br>
                }) <br>
            } <br>
        } <br>
        obj.func() <br>
        կտպի [object Window] երեք անգամ <br>
        <br><br>

        պատասխան <br>
        1. <br>
        const obj = { <br>
            func: function() { <br>
                alert(this);  // [object Object] <br>
                [4, 5, 6].forEach(function(val) { <br>
                    alert(this); <br>
                }.bind(this)); <br>
            } <br>
        }; <br>
        obj.func(); <br>
        կտպի [object Object] հետո [object Object] երեք անգամ <br>
        <br><br>

        2. <br>
        const obj = { <br>
            func: function() { <br>
                alert(this);  // [object Object] <br>
                [4, 5, 6].forEach(function(val) { <br>
                    alert(this); <br>
                }, this); <br>
            } <br>
        }; <br>
        obj.func(); <br>
        կտպի [object Object] հետո [object Object] երեք անգամ <br>
        <br><br>

        3. <br>
        const obj = { <br>
            func: function() { <br>
                alert(this);  // [object Object] <br>
                [4, 5, 6].forEach((val) => { <br>
                    alert(this); <br>
                }); <br>
            } <br>
        }; <br>
        obj.func(); <br>
        կտպի [object Object] հետո [object Object] երեք անգամ <br>
        <br><br>

        խնդիր 2 <br>
        ինչպես անենք որպեսզի func ֆունկցիայի this-ը լինի forEach-ին տված ֆունկցիայի this-ը <br>
        <br>
        const obj = { <br>
            name: "Joe", <br>
            func: function() { <br>
                [4, 5, 6].forEach(function(val) { <br>
                    alert(this.name) <br>
                }) <br>
            }, <br>
            // կտպի դատարկ տեքստ երեք անգամ   /// this: window <br>
            <br>
            // 1. <br>
            // func: function() { <br>
            //     [4, 5, 6].forEach(function(val) { <br>
            //         alert(this.name) <br>
            //     }.bind(this)) <br>
            // }, <br>
            // // կտպի Joe երեք անգամ <br>
            <br>
            // 2. <br>
            // func: function() { <br>
            //     [4, 5, 6].forEach(function(val) { <br>
            //         alert(this.name) <br>
            //     }, this) <br>
            // }, <br>
            // // կտպի Joe երեք անգամ <br>
            <br>
            // 3. <br>
            // func: function() { <br>
            //     [4, 5, 6].forEach((val) => { <br>
            //         alert(this.name) <br>
            //     }) <br>
            // } <br>
            // // կտպի Joe երեք անգամ <br>
        }; <br>
        obj.func(); <br>
        <br><br>

        4. <br>
        const F = function() { <br>
            // this = {} <br>
            this.name = "Joe" <br>
            // return this; <br>
        } <br>
        <br>
        const a = new F() <br>
        <br>
        alert(a) <br>
        կտպի [object Object]  /// a:{name: "Joe"} <br>
        <br><br>

        const F = () => { <br>
            // this = {} <br>
            this.name = "Joe" <br>
            // return this; <br>
        } <br>
        <br>
        const a = new F() <br>
        alert(a) <br>
        // error: F is not a constructor <br>
        <br>
        
        երբ որ մենք ստեղծում ենք arrow ֆունկցիա new-ով այլևս չենք կարող կանչենք <br>
        այսինքն arrow ֆուկցիան որպես constructor որպես object կառուցող մենք չենք կարող օգտագործենք <br>
        <br><br>

        5. <br>
        5.1 <br>
        arguments-ը զանգվածի պես մի object-ա որի մեջ կան բոլոր են արժեքները որոնք որ եկան մտան իր մեջ այսինքն arguments[0]-ն դա նույն է ինչպես որ a-ն, arguments[1]-ն դա նույն է ինչպես որ b-ն, arguments[2]-ն դա նույն է ինչպես որ c-ն <br>
        const f = function(a, b, c) { <br>
            alert(arguments[0] + arguments[1] + arguments[2]) <br>
            //   alert(typeof(arguments))          // object <br>
            //   alert(Array.isArray(arguments))   // false <br>
            //   alert(JSON.stringify(arguments))   // կտպի {"0":4,"1":5,"2":6} <br>
        } <br>
        <br>
        f(4, 5, 6); <br>
        կտպի 15 <br>
        <br>
        այսինքն առաջին արժեքը տակից վերագրված է 0 տեքստային արժեք անունի մեջ, եկրորդ արժեքը տակից վերագրածա 1 տեքստային արժեքի մեջ և այլն <br>
        <br><br>

        5.2 <br>
        եկեք debugger-ով նայենք որպեսզի տեսնենք arguments-ը ինչա <br>
        <br>
        const f = function(a, b, c) { <br>
            debugger <br>
        } <br>
        <br>
        f(4, 5, 6); <br>
        <br>
        arguments-ը object-ա զանգվածին նման որի 0-ի մեջ կա իրեն փոխանցած առաջի արժեքը, 1-ի մեջ կա իրեն փոխանցած երկրորդ արժեքը և այլն <br>
        այսինքն arguments-ը մեզ հնարաորություն է տալիս կարդալ բոլոր են արժեքները որոնք որ մեր ֆունկցիան ընդունեց <br>
        <br><br>
                
        /* <br>
        <br>
        ստուգելու համար <br>
        alert(Array.isArray([1, 2]))   // true <br>
        alert(typeof([1, 2, 3]))       // object <br>
        alert(JSON.stringify([1, 2, 3]))   // [1, 2, 3] <br>
        alert(JSON.stringify({0: 1, 121: "d", ds:2}))   // {"0":1, "121": "d", "ds":2} <br>
        <br><br>

        մենք գիտեյնք որ մենք կարող ենք նաև արժեքին անուն հայտարարել առանց երկու ստորակետների եթե մեր ստեղծած անունը համապատասխանում է բոլոր օրենքներին որը մենք ունենք փոփոխական ստեղծելուց <br>
        // սխալով // <br>
        ոչ թե կարող ենք հայտարարնենք անուն արժեքին առանց երկու ստորակտետների եթե մեր ստեղծած անունը համապատասխանում է բոլոր օրենքներին որը մենք ունենք փոփոխական ստեղծելուց այլ կարող ենք <br>
        այլ կարող ենք հայտարարնենք անուն արեժեքին առանց երկու ստորակտետների եթե մեր ստեղծած անունը ՉԻ համապատասխանում բոլոր օրենքներին որը մենք ունենք փոփոխական ստեղծելուց այսինքն կարող է նաև որպես անուն թիվ լինել <br>
        ուղղակի եթե անունը թիվ է չենք կարող վերցնենք արժեքը կետով <br>
        <br><br>

        // 1 // <br>
        1.1 <br>
        let x = {"age":10, "name":"hakob"}; <br>
        alert(x["age"]); <br>
        alert(x.name); <br>
        <br>
        1.2 <br>
        let x = {age:10, name:"hakob"}; <br>
        alert(x["age"]); <br>
        alert(x.name); <br>
        <br>

        // 2 // <br>
        2.1 <br>
        let r = {0: "as", "1": "ad", d: "sa", "b": "da"} <br>
        alert(r[0])     // կտպի as <br>
        alert(r["0"])   // կտպի as <br>
        alert(r.0)      // error <br>
        alert(r."0")    // error <br>
        alert(r[d])     // error: d i s not defined <br>
        <br>
        2.2
        let r = {0: "as", "1": "ad", d: "sa", "b": "da"} <br>
        alert(r[1])     // կտպի ad <br>
        alert(r["1"])   // կտպի ad <br>
        alert(r.1)      // error <br>
        alert(r."1")    // error <br>
        <br>
        2.3 <br>
        let r = {0: "as", "1": "ad", d: "sa", "b": "da"} <br>
        alert(r[d])     // error: d is not defined <br>
        alert(r["d"])   // կտպի sa <br>
        alert(r.d)      // կտպի sa <br>
        alert(r."d")    // կտպի error <br>

        <br>
        */ <br>

        <br><br>
        
        5.3 <br>
        սովորական ֆունկցիանները ունեն այդ հնարաորությունը կարող եք գրեք arguments և ինքը ձեզ կվերադարձնի բոլոր են արժեքները որոնք որ ձեր ֆունկցիան ընդունեց <br>
        arrow ֆունկցիան չունի դա <br>
        <br>
        const f = (a, b, c) => { <br>
            alert(arguments) <br>
        } <br>
        f(4, 5, 6) <br>
        <br>
        // error: arguments is not defined at f <br>
        <br><br>

        5.4 <br>
        arguments object-ը մեզ իրականում պետք չի գալիս եթե մենք ուզում ենք ուղղակի մի հատ զանգված ստանանք բոլոր մեր արժեքների մենք ընդամենը կարող ենք սենց անենք(օգտագործենք spread օպերատորը) <br>
        const f = function(...args) { <br>
        } <br>
        f(4, 5, 6) <br>
        և էտ args-ը հիմա կլինի մի հատ զանգված որի մեջ կլինի բոլոր են արժեքները որոնք մենք փոխանցել ենք <br>
        <br><br>

        6. <br>
        եթե մեր ֆունկցիան ընդամենը ունի մեկ տող մեկ ինչ որ հայտարարություն, մեկ ինչ որ գործողություն <br>
        մենք կարող ենք անել <br>
        <br>
        const f = () => { <br>
            return 5 <br>
        } <br>
        f() <br>
        <br>
            || <br>
            \/ <br>
            <br>
        const f = () => 5 <br>
        f() <br>
        <br><br>
        
        const f = (a, b) => { <br>
            return a + b <br>
        } <br>
        alert(f(4, 5)) <br>
        <br>
            || <br>
            \/ <br>
            <br>
        const f = (a, b) => a + b <br>
        alert(f(4, 5)) <br>
        <br><br>

        7. <br>
        7.1 <br>
        function F() { <br>
            // this = {} <br>
            this.name = "Joe"; <br>
            this.sayHi = () => { <br>
                alert(this.name) <br>
            }; <br>
            // return this <br>
        } <br>
        <br>
        const a = new F(); <br>
        a.sayHi(); <br>
        կտպի Joe <br>
        <br><br>

        7.2 <br>
        function F() { <br>
            // this = {} <br>
            this.name = "Joe"; <br>
            this.sayHi = () => { <br>
                alert(this.name) <br>
            }; <br>
            // return this <br>
        } <br>
        <br>
        const a = new F(); <br>
        <br>
        const b = a.sayHi; <br>
        b(); <br>
        կտպի Joe <br>
        <br>
        ամենակարևոր, ամենամեծ տարբերությունը սովորական ֆունկցիայի և arrow ֆունկցիայի նա է որ երբ որ սովորական ֆունկցիա ենք ստեղծում իրա this-ը որոշվում է այն պահին երբ մենք իրեն կանչում ենք և ամեն ինչ կախվածա թե ոնց ենք իրեն կանչում իսկ arrow ֆունկցիայի ժամանակ իրա this-ը որոշվում է են պահին երբ մենք իրեն հայտարարում ենք երբ իրեն ստեղծում ենք հետո արդեն ոնց ենք իրան կանչում կապ չունի որովհետև իրա this-ը արդեն որոշված է <br>
        <br><br><br>
    </h2>

        <hr>
        <h1>
          Վարժություններ
        </h1>
        <hr>
        <br>

    <h2>
        վարժություն 1 <br>
        <br>     
        -Մաքրեք այս կոդը <br>
        -Ինչ է արդյունքը? <br>
        <br>
        const a = { <br>
            age: 22, <br>
            name: "Joe", <br>
            getName: function() { <br>
                    return this.name; <br>
            }, <br>
            getAge: () => this.age <br>
        }; <br>
        <br>
        alert(a.getName());  // "Joe" <br>
        alert(a.getAge());   // undefined <br>
        <br>
        arrow ֆունկցիայի this-ը որոշվում է են պահից երբ նա ստեղծվում է ոչ թե կանչվում <br>
        և իրա this-ը ստանում է իրա ծնող ֆունկցիայից այսինքն այն ֆունկցիայի this-ն է լինում իրա this-ը որի մեջ ինքը կա <br>
        <br>
        այս դեպքում այս ֆունկցիան չի ստեղծված որևէ ֆունկցիայի մեջ սրանից վերև ոչ մի ֆունկցիա չկա որ փաթաթում է իրեն(որի մեջ ինքը գտնվում է) հետևաբար ինքը ընդունում է որպես իրա this գլոբալ object-ը(window object-ը) <br>
        իսկ գլոբալ object-ը(window object-ը) age չունի հետևաբար մենք կստանանք undefined <br>
        <br><br>

        վարժություն 2 <br>
        <br>  
        -Մաքրեք այս կոդը <br>
        -Ինչ է արդյունքը? <br>
        <br>
        const f = () => this.name; <br>
        <br>
        function f2() { <br>
            return this.name; <br>
        } <br>
        <br>
        const a = { <br>
            name: "Mike" <br>
        }; <br>
        <br>
        alert(f2.apply(a)) // "Mike" <br>
        alert(f.call(a));  // "" <br>
        <br><br>

        սովորական ֆունկցիայի this-ը որոշվում են պահին երբ մենք իրեն կանչում ենք բայց arrow ֆունկցիայի this-ը որոշվում է են պահից երբ նա ստեղծվում է ոչ թե կանչվում <br>
        arrow ֆունկցիայի this-ը արդեն որոշված է, ոնց ուզում ենք կանչենք իրա this-ը արդեն որոշված է <br>
        իսկ եթե ինքը ստեղծվում է գլոբալ scope-ի մեջ ինքը ոչ մի ֆունկցիայի մեջ չի փաթեթաորված իրա this-ը կլինի գլոբալ object-ը այսինքն window-ն <br>
        <br>
        հետևաբար ինքը ընդունում է որպես իրա this գլոբալ object-ը(window object-ը) <br>
        իսկ գլոբալ object-ի(window object-ի) name-ը դատարկ տեքստ է("") հետևաբար մենք կստանանք դատարկ պատուհան <br>
        <br><br>


        վարժություն 3 <br>
        <br>  
        -Մաքրեք այս կոդը <br>
        -Ինչ է արդյունքը? <br>
        <br>
        function f() { <br>
            // this = a <br>
            return () => this.age; <br>
        }; <br>
        <br>
        const a = { <br>
            age: 22 <br>
        }; <br>
        <br>
        const z = f.call(a); <br>
        alert(z());  // 22 <br>
        <br>
        alert(f.call(a)()); // 22 <br>
        <br><br>


        վարժություն 4 <br>
        <br>  
        -Մաքրեք այս կոդը <br>
        <br>
        let a = [5, 40, 29, 44, 33]; <br>
        <br>
        function o() { <br>
            let b = []; <br>
            a.map(function(val) { <br>
                    b.push(val + 1); <br>
            }); <br>
            <br>
            let z = b.filter(function(val) { <br>
                    return val % 2 === 0; <br>
            }); <br>
            <br>
            return z; <br>
        } <br>
        <br>
        o() <br>
        <br><br>

        let a = [5, 40, 29, 44, 33]; <br>
        <br>
        function transform(arr) { <br>
               return arr <br>
                         .map((val) => val + 1) <br>
                         .filter((val) => val % 2 === 0); <br>
        } <br>
        <br>
        alert(transform(a));  // [6, 30, 34] <br>

    </h2>


    <script src="index48js.js"></script>
</body>

</html>

