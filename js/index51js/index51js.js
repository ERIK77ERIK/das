// // 1
// // interface(միջնորդ)

// // ավտոմեքենայի օրինակը
// // ավտոմեքենայի պեդալը միջնորդ է մեր և մի շատ բարդ, շատ կոմպլեքս համակարգի
// // մենք և որ վարում ենք չենք խորանում ինչպես է աշխատում մենք ընդամենը սխում ենք այս պեդալը և շարժվում է մեքենան 
// // այսինքն այդ պեդալը միջնորդ է մեր և մի շատ բարդ համակարգի

// // միջնորդ ծրագրաորման ոլորտում կոչվում է interface այսինքն ըտեղ ոնցոր վարորդային interface-ա պեդալը մեզ համար որպեսզի մենք շփվենք ներքին մեքենայի համակարգի հետ

// // երբ որ մենք խոսում ենք ծրագիրների մասին կա օգտագործողը, էն ով որ համակարգիչի առաջ նստածա և աշխատումա մեր ծրագրի հետ դա անգլերեն կոչվում է user(օգտագործող) 
// // user-ի հետել կա interface այսինքն օգտագործողը երբ որ շփվումա մեր ծրագիրների հետ ինքը չի կոդ գրում ինչ որ ֆունկցիաներ կանչում ինքը տեսնումա ինչ որ կոճակներ, պատուհաներ, ինչ որ մուկով խաղումա 
// // պատուհանները, կոճակները այդ պատկերը որ մենք տեսնում ենք էկրանի վրա դա միջնորդ է մեր և տակի կոդի մեջտեղը նույն ձևի ոնց որ ոտնակը պեդալը միջնորդ է մեր և օրինակ շարժիչի մեջտեղը

// // այսինքն userinterface-ը հնարաորությունա տալիս օգտագործողին շփվել ծրագրի հետ առանց կոդ գրելու ուղղակի կոճակը սեխմելով մուկը շարժելով և այլն 


// // 2.
// // application programming interface(հավելվածի ծրագրավորման ինտերֆեյս)
// // object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում) Encapsulation կոնցեպտը


// // հիմա նույնպես ինչպես որ կա userinterface այն ով որ շփվում է համակարգի հետ նաև կա programming interface հիմանականում կոչվում է application programming interface(հավելվածի ծրագրավորման ինտերֆեյս), programming նշանակումա ծրագրաորում


// // programming interface-ը ինչ է
// // երբ որ որևէ ծրագրաորող ստեղծում է ինչ որ մի համակարգ ինչ որ մի կոդ և ուզում է որ ուրիշ ծրագրաորողը էտ կոդը օգտագործի ինքը սենց չի սենց տալիս մի հատ սենց մեծ գիգանտ ու ասումա դե տես ինչ էս անում 
// // ինքը այդ կոդը այդ բարդ լոգիկան որ ինքը գիշերներով ցերեկներով տանջվել ստեղծելա ստեղծումա իր շուրջը մի հատ interface մի հատ միջնորդ որը պարզ պատուհան է ստեղծում միջնորդ է ստեղծում մեր այսինքն մնացած ծրագրաորողների ու իր ստեղծված կոդի մեջտեղը նույն ձևի ոնց որ պեդալը ստեղծում է մի պարզ շփում ձեր ու ներքին էտ բարդ համակարգի մեջտեղը


// // որտեղ ենք մենք այդպիսի բան տեսել
// // դետալները թե ինչ է կատարվում context-ի մեջ ոնց է ինքը նկարում նկարը canvas-ի վրա ինչ փոփոխականներ է օգտագործում ինչ ուրիշ արժեքներ ունի ինչ լոգիկա ունի ոնց է էտ ամենը անում մեզ չի հետաքրքրում երբ որ մենք օգտագործում ենք context-ը նույն ձևի ոնց որ մեզ չի հետաքրքրում մեքենայի համակարգը ներքին ինչպես է աշխատում երբ որ մենք ընդամենը գազն ենք սխմում 
// // այսինքն երբ որ մենք հիմա էս context-ին անում ենք ասենք context.fillRect() և տալիս ենք ինչ որ մի քանի պարամետրներ մենք չենք խորանում ինքը տակից ինչ է կատարվում էս ինչ է անում էտ ամենինչը փաթեթաորված ու պահված է մեզնից մեզ ընդամենը տրվումա որոշ ֆունկցիաներ այսինքն մեզ տրվումա application programming interface(հավելվածի ծրագրաորման interface) միջնորդ ֆունկցիաներ որի միջոցով մենք շփվում ենք context-ի հետ որպեսզի ինքը տակից նկարի canvas-ի վրա


// // այսինքն incapsulation-ի միտքը ինչումա որ երբ որ մենք ստեղծում ենք object-ներ որոնք ունեն ֆունկցիաներ և ինչ որ արժեքներ փաթեթաորված հիմնականում մի հատ object-ի մեջ ներքին ինֆորմացիան լավ կլինի որ մեզնից պահպանվի


// // ինչու ենք պահպանում ինչի ցույց չպետքա տանք ներքին ինֆորմացիան
// // դե եկեք վերադարնանք մեքենայի օրինակին ․․․․ պատկերացրեք մեքենայի ներքին էլեկտրոնիկան մեր դիմացը երևար փակված չլիներ երբ որ մենք վարում ենք մեքենան դա կբերեր երկու պոտենցյալ խնդիրների
// // 1. առաջինը երբ որ մենք ստանում ենք էտքան շատ ինֆորմացիա երբ որ էտքան շատ կոճակ կա էտ շատ տաբերակներ կան շնուր կա և այլն մենք շատ հեշտ կարող ենք շփոթվենք, խճճվենք մենք որպես օգտագործող ուզում ենք կենտրոնանանք տուր ինձ ղեկ, տուր ինձ պեդալ տուր ինձ մի քանի ուրիշ բան որպեսզի ես իմ գործը անեմ են մնացածը ինչ որ ինձ պետք չի վարելու համար ինչ էս ինձ ցույց տալիս էտ ավելորդ ինֆորմացիայա որ ես պետքա հիմա փորձեմ հասկանալ ասեմ մի րոպե էս չի կարելի ձեռք տալ բայց էս պետքա ձեռք տալ, ավելորդ ինֆորմացիա user-ին պետք չի տալ որովհետև շատա լինում ինքը խճճվում է 
// // 2. երկրորդը պատկերացրեք որ ես վարելուց հանկարծակի մի շնորհը պոկում եմ, ինչ է ստացվում որ ես հիմա ինչ որ մի բանով ջարդեցի կամ խանգարեցի ներքին system-ը կարողա էտ շնորհը ինչ որ կարևոր սիգնալ էր ուղարկում ինչ որ մի տեղից ուրիշ տեղ որը կարևոր էր մեքենայի շարժվելու համար ու դրա պատճառով մեքենան կարող է այլևս ճիշտ չաշխատի 
// // նույն օրինակը եկեք բերենք ծրագրաորման մեջ
// // 1. առաջինը պետք չի երբ որ մենք որևէ object ենք ստեղծում որ ինքը ունենա լիքը ուրիշ տարբեր ֆունկցիաներ,և լիքը տարբեր ինֆորմացիա որովհետև էտ ժամանակ օգտագործողը(ծրագրաորողնելա օգտագործող) կխճճվի, մենք էլ են երբ որ ինչ որ object ենք տեսնում երբ որ ունի չգիտեմ 90000 հատ ֆունկցիա մենք խճճվում ենք հիմա որը կանչեմ ինձ ընդամենը պետք էր մի հատ rect նկարել ինչ եք ինձ տալիս 300հատ ֆունկցիա ու լիքը ուրիշ փոփոխականներ ինձ տուր մի քանի հատ ֆունկցիա բացատրի ոնց էն աշխատում ես բռնեմ օգտագործեմ canvas-ը կամ context-ը, միտքը դրանումա
// // 2. երկրորդը եթե ներքին ինֆորմացիան ես կարող եմ տեսնեմ ես միգուցե հանկարծակի փոխեմ նենց ոնց որ պետք չէր և տակի լոգիկան էտ object-ի ես կարողա հանկարծակի, անպայման չի ուզենալով բայց հանկարծակի կարողա ցխեմ օրինակ ինչ որ փոփոխականը որը պետք էր որ լիներ թիվ հանկարծակի դարձնեմ ինչ որ տեքստ օրինակ կամ են թիվը որը պետք էր որ լիներ պլյուս հանկարծակի դարձնեմ մինուս, հազար ու մի բան կարող եմ անել որը object-ի տակի լոգիկան կարող է վնասի
// // այս երկու պատճառով 

// // object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում) Encapsulation կոնցեպտը ասում է հետևյալը որ երբ որ մենք սեղծում ենք object-ներ լավ կլինի որ ներքին ինֆորմացիան մենք պահենք որպեսզի առաջինը օգտագործողը չխճճվի և երկրորդը հանկարծ դրսից ինչ որ բան չփոխեն ու ներքին լոգիկան չվնասվի

// const canvas = document.querySelector("canvas");
// const context = canvas.getContext("2d");

// context.fillRect();

// let data = {
//     // game data
// };

// function update() {
//     // update data
// }

// function render() {
//     context.clearRect(0, 0, canvas.width, canvas.height);
//     // render data
// }


// function loop() {
//     requestAnimationFrame(loop);
//     update();
//     render();
// }

// loop();

// document.addEventListener("keydown", (evt) => {
//     if(evt.code === "ArrowRight") {
//         // go right
//     } else if (evt.code === "ArrowLeft") {
//         // go left
//     }
// })

// document.addEventListener("keyup", (evt) => {
//     // stop moving
// })



// // 3
// // եկեք կոդ ուսունասիրենք որ կոնկրետ հասկանանք ինչն է իմաստը
// // 3.1

// const canvas = document.querySelector("canvas");
// const context = canvas.getContext("2d");

// context.fillRect();

// let data = {
//     // game data
// };

// function update() {
//     // update data
// }

// function render() {
//     context.clearRect(0, 0, canvas.width, canvas.height);
//     // render data
// }

// function loop() {
//     requestAnimationFrame(loop);
//     update();
//     render();
// }

// loop();

// document.addEventListener("keydown", (evt) => {
//     if(evt.code === "ArrowRight") {
//         // go right
//     } else if (evt.code === "ArrowLeft") {
//         // go left
//     }
// })

// document.addEventListener("keyup", (evt) => {
//     // stop moving
// })



// // 3.2
// 1 //
// // ինչպես ենք մտածում կոդը գրելուց

// // այս օրինակում որտեղ մենք սփռված ունենք լիքը ինֆորմացիա 
// // երբ որ մենք հիմա ուզում ենք օգտագործենք հերոսին, ուզում ենք հիմա նենց անենք որ հերոսը աջ գնա, մենք պետք է գնանք խորանանք իրա լոգիկայի մեջ ասենք update-ը կախվածա xDelta-ից հետևաբար ես պետքա xDelta-ն փոխեմ, delta-ն նույնիսկ ինչա ինչ xDelta էս ինչ մաթեմա լավ ասենք թե ու տենց հիշենք ու հասկանանք լավ data.hero.xDelta-ն պետքա դարձնենք թիվ բայց ինչ թիվ 1, 10, 20 լավ եկեք 1 իսկ եթե ձախ գնա թող -1 լինի  ենթադրում եմ մի րոպե մաթեմս ճիշտ էր ու սենց խառը մտածում ենք հետո հասկանում ենք մի րոպե եթե ուզում ենք ինքը կանգնի որն ենք օգտագործում ինչ որ delta կար պատկերացնում եք չէ էս ամենինչը ես մտածում եմ որպեսզի էս կոդը գրեմ data.hero.xDelta = 0
// // update-ի մեջ կանչում ենք data.hero.update()
// // և render-ի ժամանակ նախ և առաջ ջնջում ենք էղած ինֆորմացիան canvas-ից և նկարում ենք մեր հերոսին այսինքն
// // function render() {
// //     context.clearRect(0, 0, canvas.width, canvas.height);
// //     data.hero.render()
// // }
// // էդքան բան էսել մեր հերոսն է ում մենք կարող ենք աջ տանել կամ ձախ տանել

// 2 //
// // տաբերակա կստացվի բայց դժվարացնումա մտածելը և կարող է պատահմամբ վնասենք կոդը

// // աշխատումա բայց ինչպես տեսնում եք իրա ներքին ինֆորմացիան էտ փաստը որ այ սենցա կոդը գրած կարող է խնդիրներ տալ և դժվարացնումա մտածելը, որ ինքը ինչ որ delta ունի որը ինչ որ մաթեմա անում x-ի վրա որը որոշում է ինքը որտեղ պետքա շարժվի և էս բոլոր փոփոխականները սենց սփռված են իրա վրա այսինքն ես ստեղ ցանկացած տեղից կարող եմ ասեմ data.hero. ասենք x-ը և քցեմ ինչ որ տեքստ օրինակ որը պարզա հետո մաթեմից հետո կտա NaN և ոչ մի բան չի աշխատի
// // այսինքն ես շատ հեշտ կարող եմ իրեն վնասեմ բացի դրանից եթե ես փորձեմ ուսումնասիրել հերոսին կամ օրինակ debugger-ով նայեմ հերոսի object-ին ինչ է կցած ես կտեսնեմ այ էս ամենինչը ինչ որ delta-ներ ինչ որ x ինչ որ եսիմ ինչ ինչ որ y բան, երբ որ ընդամենը ինձ պետք է հասկանալ մի րոպե լավ էս ամեն ինչը հասկացանք բայց ոնց անեմ որ ինքը աջ գնա կամ ձախ


// // ավելի պարզ տարբերակը եթե մենք օգտագործենք encapsulation հետևյալն է


// const canvas = document.querySelector("canvas");
// const context = canvas.getContext("2d");

// const heroImg = document.createElement("img");
// heroImg.src = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwx3cRyk0JKQEKJAHw9OglG6QpBa0Hqps4qQ&usqp=CAU"

// let data = {
//     hero: {
//         xDelta: 0,
//         yDelta: 0,
//         x: 10,
//         y: 10,
//         width: 40,
//         height: 40,
//         update() {
//             this.x += this.xDelta;
//             this.y += this.yDelta;
//         },
//         render() {
//             context.drawImage(heroImg, this.x, this.y, this.width, this.height);
//         }
//     }
// };

// function update() {
//     data.hero.update()
// }

// function render() {
//     context.clearRect(0, 0, canvas.width, canvas.height);
//     data.hero.render()
// }


// function loop() {
//     requestAnimationFrame(loop);
//     update();
//     render();
// }

// loop();


// document.addEventListener("keydown", (evt) => {
//     if(evt.code === "ArrowRight") {
//         data.hero.xDelta = 1
//     } else if (evt.code === "ArrowLeft") {
//         data.hero.xDelta = -1
//     }
// })

// document.addEventListener("keyup", (evt) => {
//     data.hero.xDelta = 0
// });





// // 3.3
// // ավելի պարզ տարբերակը եթե մենք օգտագործենք encapsulation կոնցեպտը
// // հետևյալն է

// 1 // 
// // encpapsulation կոնցեպտը այս հերոսի օրինակում 


// // ստեղծում ենք մի հատ function constructor

// // սա կստեղծի մեր հորոսին ինքը թող ընդունի նախնական արժեքներ ինքը ներքին բլոկից թող ունենա xDelta որը թող լինի 0 և yDelta-որը թող լինի 0 ինչպես տեսնում եք ես էս this-ին չեմ կպցնում ուղղակի ստեղծում եմ փոփոխականներ որոնք որ քանի որ այ էս  ֆունկցիայի(Hero ֆունկցիայի) մեջ են դրսից իրանք անհասանելի են clouser-ի մասը հիշում եք այսինքն հիմա որպեսզի իրանց հետ շփվենք մեզ պետք են ֆունկցիաներ դե եկեք նախ և առաջ ավելացնենք այս էղած ֆունկցիաները update-ը որը ինչ կանի եղած x-ը կավելացնի xDelta-ով և էղած y-ը կավելացնի yDelta-ով այսինքն սա քանի որ ստեղծումա clouser այս ֆունկցիան(update ֆունկցիան) հերիք չի ունի այ էս լոգիկան ինքը նաև կպահպանի հղումը դեպի այ էս x, y, xDelta և yDelta փոփոխականների ու կշարունակի աշխատել  
// // նաև եկեք ստեղծենք render-ը, հիմա նայեք ստեղ էս հերոսը նկարը որ ստեղ դուրսը քցած էր ինչիա դուրսը քցած բա որ ինչ որ մեկը փոխի բա որ ինչ որ խնդիր առաջանա ում էր պետք էս հերոս նկարը բացի մեր հերոսից որպեսզի ինքն իրեն նկարի եկեք սա հանենք ստեղից և գցենք մեր հերոսի constructor-ի մեջ, հիմա մեր հերոսի function constructor-ը իր մեջ կստեղծի սովորական փոփոխական ոչ թե this-ին կավելացնի, object-ին չի կպցնում ուղակի ստեղծումա փոփոխական heroImg որին կցումա այդ նկարը և render-ը հիմա կարող է նկարել էտ փոփոխականներով քանի որ հասանելի են այդ փոփոխականները 
// // այսինքն render-ը գիտի ինչպես նկարել մեր հերոսին, նկարը մեջնա էտ ամենինչը իրա հետ փաթեթաորվածա քանի որ ինքը clouser-ա, update-ը գիտի ինչպես իրեն թարմացնի

// // դե էս ամինինչի տեղը(data-ի մեջի ինֆորմացիայի տեղը) եկեք ընդամենը անենք new Hero() և պաս տանք նախնական իրա տեղը որտեղ ինքը սկսումա x, y, և չափը width, height

// // հիմա եկեք ստեղ քանի որ մեր xDelta-ն այլևս կցած չի մեր հերոսին սենց անելը չենք կարող այսինքն մենք ընդամենը ավելացնում ենք ինչ որ xDelta հերոսին բայց ինքը տակից դա չի օգտագործում, this.xDelta-ն չի օգտագործում ինքը օգտագործումա հենց այ էս let xDelta-ն 
// // հետևաբար տենց չի լինի նայեք ինչ ենք անում ուզում էս աջ գնաս ոնց որ մեքենանա ասում ուզում էս աջ գնաս դու մի խորացի մի հատ ղեկ կա ուզում էս աջ գնաս աջ պտտացրու ուզում էս ձախ գնաս ձախ պտտացրու նույնը մենք կարող ենք ասենք հերոսի կողմից ուզում ես աջ գնանք xDelta, yDelta, մաթեմ գործ չունես նայի ինչ էս անում ստեղծում ենք մի հատ ֆունկցիա function կոչվումա goRight(գնա աջ) որը հղում է մի հատ ֆունկցիայի որը պետք է նենց անի որ մեր հերոսը գնա աջ այ հիմա ներքին բլոկից ինքը թող որոշի ինչ մաթեմա պետք դե մեզ պետքա նենց անել որպեսզի xDelta-ն լինի ասենք թե 1, ձախ էս ուզում գնաս ոչ մի խնդիր մի հատ էլ ֆունկցիա տամ this.goLeft = () => {} իր մարմնում թող լինի xDelta = -1,  ուզում էս ստոպ տա էլ չշարժվի խնդիր չկա this.stop = () => {xDelta = 0}

// // իսկ ստեղ որպեսզի ասենք հերոս գնա աջ ընդամենը կանչում ենք գնա աջ ֆունկցիան data.hero.goRight(), ուզում ենք գնա ձախ կանչում ենք data.hero.goLeft() ուզում ենք կանգնի data.hero.stop()


// // այսինքն հիմա հերոսի հետ շփումը դրսից շատ ավելի պարզա երբ որ մենք ունենք հերոս object-ը մենք ընդամենը կանչում ենք ֆունկցիաներ և ինքը արդեն բոլոր գործողությունները նկարելը աջ գնալը ձախ գնալը և այլն անումա, ոնց է անում ինչ փոփոխականներ է օգտագործում ինքը օգտագործում է xDelta թե էս փոփոխականի անունը լինումա xեսիմինչ թե ինչ այլևս մեզ չի հետաքրքրում մենք ունենում ենք մի հատ object և իրա հետ շփվում ենք, ամբողջ լոգիկան և ամբողջ ինֆորմացիան որը իրան պետք է որպեսզի ինքը իրա գործը անի փաթեթաորված է իր մեջ նույն ձևի ոնց էտ ամբողջ համակարգը մեքենայի փաթեթաորվածա էտ մեքենայի դիմացի մի հատ բլոկի մեջ ու փագածա մեզնից մեզ տվածա ընդամենը մի հատ ղեկ մի քանի պեդալ և մի քանի ինչ որ ուրիշ բաներ դա ավելի պարզ է մեր համար որպեսզի իրա հետ շփվել և իհարկե չվնասել հանկարծակի
const canvas = document.querySelector("canvas");
const context = canvas.getContext("2d");

function Hero(x, y, width, height) {
    
    const heroImg = document.createElement("img");
    heroImg.src = "https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwx3cRyk0JKQEKJAHw9OglG6QpBa0Hqps4qQ&usqp=CAU"

    let xDelta = 0;
    let yDelta = 0;

    this.update = () => {
        x += xDelta;
        y += yDelta;
    };

    this.render = () => {
        context.drawImage(heroImg, x, y, width, height);
    };

    this.goRight = () => {
        xDelta = 1;
    };
    this.goLeft = () => {
        xDelta = -1;
    };
    this.stop = () => {
        xDelta = 0;
    }

}


let data = {
  hero: new Hero(20, 20, 40, 40)
};


function update() {
    data.hero.update()
}

function render() {
    context.clearRect(0, 0, canvas.width, canvas.height);
    data.hero.render()
}


function loop() {
    requestAnimationFrame(loop);
    update();
    render();
}

loop();



document.addEventListener("keydown", (evt) => {
    if(evt.code === "ArrowRight") {
        data.hero.goRight();
    } else if (evt.code === "ArrowLeft") {
        data.hero.goLeft();
    }
})

document.addEventListener("keyup", (evt) => {
    data.hero.stop();
});


/* 
encapsulation կոնցեպտը OOP-ում ունի շատ պարզ միտք որ երբ որ մենք ստեղծում ենք object-ներ ինֆորմացիան մենք փագենք փաթեթաորենք և տրամադրենք ֆունկցիաներ որպես interface որպես application programming interface որպեսզի շփվենք դսից, ծրագրաորողները շփվեն մեր object-ի հետ, շփվեն շատ պարզ էտ ֆունկցիաները պետք է լինեն շատ պարզ որպեսզի հեշտորեն շփվեն լավ կլինի անունները այդ ֆունկցիաների լինեն ակնհայտ որպեսզի հենց անունը ասի անմիջապես անունը կարդալով պարզ լինի իրա դերը ինչ է
*/



// 4.
// encapsulation կոնցեպտը OOP-ում ունի շատ պարզ միտք որ երբ որ մենք ստեղծում ենք object-ներ ինֆորմացիան մենք փագենք փաթեթաորենք և տրամադրենք ֆունկցիաներ որպես interface որպես application programming interface որպեսզի շփվենք դսից, ծրագրաորողները շփվեն մեր object-ի հետ, շփվեն շատ պարզ էտ ֆունկցիաները պետք է լինեն շատ պարզ որպեսզի հեշտորեն շփվեն լավ կլինի անունները այդ ֆունկցիաների լինեն ակնհայտ որպեսզի հենց անունը ասի անմիջապես անունը կարդալով պարզ լինի իրա դերը ինչ է







