// // 1.
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//        alert(person.name)
//     }
// }

// person.printName()

// կտպի Joe


// // 2.
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(person.name)
//     }
// }

// let p = person
// person = 8

// p.printName()

// կտպի undefined



// // 3.
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }

// let p = person
// person = 8

// p.printName()

// կտպի Joe

// // this նշանակումա այս
// // this-ը ինչ է ինքը հղում է դեպի էն object-ին որի մեջ ֆունկցիան աշխատում է



// // 4.
// 1 //
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }

// person.printName()

// կտպի Joe

// // dott(կետ) նշանակում է այս ֆունկցիան կցած է person-ին
// // հետևաբար եթե մենք այսպես կանչում ենք printName այսինքն անում ենք այս object-ը person կետ printName() սա նշանակում է որ ես ուզում եմ աշխատացնեմ այս անունը էս object-ի մեջ 
// // հետևաբար այս ֆունկցիայի ներքին this-ը կլինի հենց էս object-ը(person-ը)


// 2 //
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }

// let p = person

// p.printName()
// կտպի Joe

// // հիմա printName ֆունկցիան կունենա որպես իր this արժեքը p-ին
// // այսինքն նույնիսկ եթե մենք person-ը հիմա փոխենք դարձնենք 9-ը սա կշարունակի աշխատել 

// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }

// let p = person
// person = 9

// p.printName()
// կտպի Joe

// // տվեց մեզ Joe ինչու որովհետև ստեղ p-ին հղված է դեպի այս object-ին հետևաբար երբ որ մենք անում ենք p կետ printName(), printName-ի this-ը դառնում է այն object-ը որը հղված է p-ով այսինքն person object-ը





// // 5.
// // էն պահին երբ որ ֆունկցիան աշխատում է էտ ժամանակ է որոշվում իրա this-ը ինչ է 

// function zoo() {
//     alert(this.name)
// }

// let person =  {
//     name: "Joe",
//     age: 33
// };

// person.foo = zoo
// person.foo()

// // հիմա this-ը ինչ կլինի zoo ֆունկցիայի
// // նույն օրենքով

// // էն պահին երբ որ ֆունկցիան աշխատում է էտ ժամանակ է որոշվում իրա this-ը ինչ է 

// // իսկ այս կոդում person.foo() ինչ object-ի մեջ է, այս ֆունկցիան աշխատում է person object-ի հետևաբար foo-ի this-ը կլինի person object-ը
// // մենք ստեղծեցինք ֆունկցիան լրիվ առանձին բայց մենք նաև էտ ֆունկցիան դրեցինք person-ի մեջ այսպես որպես foo բանալիով հետո մենք կանչեցինք այդ foo-ն հետևաբար իրա this-ը էտ պահին որոշվեց որ պետքա լինի այ էս person object-ը


// // այսինքն առաջին օրենքը ինչ է թե ինչպես պետքա որոշել this-ը ինչ է լինելու երբ որ մենք կանչում ենք ինչ որ մի ֆունկցիա կետով այսինքն ինչ որ object կետ ֆունկցիա էտ ֆունկցիան հիմա կունենա որպես this էտ object-ը 
// // այսինքն foo ֆունկցիան կունենա որպես this person object-ը





// // 6.
// function zoo() {
//     alert(this.name)
// }

// let person = {
//    name: "Joe",
//    age: 33
// }
// person.foo = zoo

// let person2 = {
//     name: "Mike",
//     age: 39
// }
// person2.foo = zoo

// person.foo()
// // կտպի Joe

// person2.foo()
// // կտպի Mike



// // 7.
// 1 //
// function zoo() {
//     alert(this.name)
// }

// // եթե մենք այս function-ը առանց կպցնելու որևէ object-ի և աշխատացնելու այսպիսի կետ սինտակտիկայով ինչ կլինի իրա this.name-ը եթե մենք ուղղակի կանչենք zoo-ին այսպես 

// function zoo() {
//     alert(this.name)    // window-ի name բանալիյի մեջ վերագրածա դատարկ տեքստ "" // եթե այս դեպքում alert անենք ուղակի this կտպի [object Window] // մնացած դեպքերում օրինակ եթե alert անենք this.age կտպի undefined
// }
// zoo()

// // երբ որ մենք ստեղծում ենք ֆունկցիան և աշխատացնում ենք իրան առանց ոչ մի հատուկ ինչ որ object-ին կցած իրա this-ը դառնումա գլոբալ արժեքը գլոբալ object-ը որը բրաուզերի մեջ կլինի window object-ը հետևաբար բայց window object-ը անուն չունի նենց որ մենք կստանանք   դատարկ պատուհան 


// 2 //
// բայց մենք էտ անունը կարող ենք փոխենք 
// function zoo() {
//     alert(this.name)
// }
// window.name = "Hopar"
// zoo()
// // կտպի Hopar




// // 8.

// // այսինքն էս պահին մենք սովորել ենք երկու օրենք թե ինչպես կարելիյա որոշել function-ի this-ը ինչ է

// 1 //
// // եթե ֆունկցիաին մենք կանչում ենք որպես ֆունկցիան կցած ուրիշ object-ի այսինքն ինչ որ object կետ էտ ֆունկցիան էտ ֆունկցիայի this-ը կլինի էտ object-ը 
// // այսինքն ստեղ եթե մենք անում ենք 

// function zoo() {
//     alert(this.name)
// }
// zoo()

// let person = {
//    name: "Joe",
//    age: 33
// }
// person.foo = zoo

// let person2 = {
//     name: "Mike",
//     age: 39
// }
// person2.foo = zoo

// person2.foo()
// // կտպի Joe

// // այսինքն this-ը foo ֆունկցիայի կլինի person2 object-ը այսինքն կետի ձախ կողմից



// 2 //
// // եթե մենք ստեղծում ենք մի հատ ֆունկցիա որը ուղղակի առանձին իրեն կանչում ենք իրա this-ը կլինի գլոբալ object-ը որը բրաուզերի մեջ դա window object-ն է 

// // կարևոր է ասել որ լիքը մարդ սխալներ են թույլ տվել այ էս պատճառով որովհետև ստեղծել են մի հատ առանձին ֆունկցիա և հետո կանչել են ենթադրելով որ this-ը կլինի ինչ որ հատուկ բան բայց ստացվելա որ this-ը գլոբալ փոփոխականն է և լիքը լոգիկայի սխալներ են թույլ տվել

// // դրա համար ստեղծվել է մի հատ strict mode(խիստ ռեժիմ), որը գրվում է "use strict"(օգտագործել խիստ) 




// // 9.
// 1 //
// // դրա համար ստեղծվել է մի հատ այսպես ասած strick mode
// // եթե մենք այս տեքստը "use strict" ամենա վերևում գրենք մեր javascript-ի, մեր javascript-ը կաշխատի մի քիչ ուրիշ, մի քիչ ուրիշ ասելով էս this-ը եթե մենք փորձենք աշխատացնել սովորական  ֆունկցիայի մեջ որը կցած չի կամ չի աշխատում որևէ կոնկրետ object-ի մեջ իրա this-ը կլինի undefined այսինքն հիմա եթե մենք սենց անենք ու print անենք this-ը, this-ը undefined է էլ գլոբալ փոփոխականը չի էլ գլոբալ object-ը չի ավելի շուտ, window-ն չի այլ undefined է


// "use strict" // օգտագործել խիստ"

// function zoo() {
//     alert(this)
// }
// zoo()

// // կտպի undefined



// 2 //
// // javascript-ը այսօրվա օրով հիմանականում գրում են strick mode-ում

// // նենց որ պետքա հասկանալ որ եթե դուք strict mode-ում ուղղակի առանձին ֆունկցիա ստեղծեք և իրան կանչեք իրա this-ը կլինի undefined
// // բայց էտ նույն ֆունկցիան եթե մենք կպցնենք ինչ որ մի object-ին և հետո ըստ էտ object-ի կանչենք իրեն այսինքն կանչենք նենց որպեսզի ինքը աշխատի էտ object-ի մեջ էտ ժամանակ իրա this-ը կլինի էտ object-ը որին մենք կարող ենք անենք this.name օրինակ էս պարագայում դա կլինի Mike այսինքն եթե ֆունկցիան կցածա մի հատ object-ին ու մենք էտ object-ի միջոցով կանչում ենք էտ ֆունկցիաին էտ ֆունկցիայի this-ը դարնումա էտ object-ը


// "use strict"

// function zoo() {
//     alert(this)    
// }
// zoo()
// // կտպի undefined

// let person = {
//     name: "Joe",    
//     age: 33,
//     printName: function() {
//         alert(this.name)    
//     }
// }
// person.foo = zoo

// let person2 = {
//     name: "Mike",    
//     age: 39
// }
// person2.foo = zoo

// person2.foo()
// // կտպի "Mike"





// // 10.
// 1 //
// // մենք բացի նրանից որ կարող ենք կպցնենք zoo-ն person-ին և ըստ էտ person-ի միջոցով կետով աշխատացնենք էտ ֆունկցիաին և հետևաբար իրա this-ը կդառնա էտ person object-ը
// // բացի դրանից կարող ենք անենք սենց 

// function zoo() {
//     alert(this.name)
// }

// let person = {
//     name: "Joe",
//     age: 33,
// }

// zoo.call()


// // հիշեք որ ֆունկցիաները javascript-ում object-ներ են հետևաբար ֆունկցիաները կարող են ունենալ իրանց մեջ ուրիշ ֆունկցիաներ օրինակ call 
// // այսինքն ինչ է ստացվում որ մենք վերցնում ենք էս ֆունկցիան կանչում ենք call ֆունկցիան որը իրան կցած է
// // call նշանակում է կանչիր
// // call-ին մենք փոխանցում ենք որպես առաջին արժեք object  context object-ը դա իրա this-ն է  այսինքն մենք որպես առաջին պարամետր ստեղ կարող ենք որոշենք իրա this-ը ինչա լինելու

// // եկեք իրա this-ը թող լինի person

// function zoo() {
//     alert(this.name)
// }
// let person = {
//     name: "Joe",
//     age: 33,
// }
// zoo.call(person)
// // կտպի joe

// // այսինքն ինչ է ստացվում որ մենք կարող ենք ինչ որ մի ֆունկցիան կանչելուց հենց էտ պահին կանչելու ժամանակ ասենք ես ուզում եմ որ քո this-ը լինի այս object-ը իսկ դա ինչպես կարող ենք անենք call-ով


// 2 //
// // դրանից հետո եթե մեր zoo-ն վերցնումա ինչ որ մի պարամետր ասենք թե txt որը ասենք գումարում ենք ստեղ ինչ որ սենց բան ենք անում դա call-ում կլինի մնացած պարամետրները այսինքն եթե մենք ստեղ տանք "my name is" ինչ որ սենց մի բան  ինչ կստացվի որ 
// // առաջին պարամետրը call-ի դա են object-ն է որը կլինի իրա this-ը իսկ մնացած պարամետրները են պարամետրներն են որոնք որ կգնան կմտնեն իրա մեջ

// function zoo(txt) {
//     alert(txt + " " + this.name)
// }
// let person = {
//     name: "Joe",
//     age: 33,
// }
// zoo.call(person, "my name is")
// // կտպի my name is Joe



// // այսինքն եթե ստեղ նաև դնեմ 2 դա կանցնի որպես երկրորդը x ասենք թե 

// function zoo(txt, x) {
//     alert(txt + " " + this.name + x)
// }
// let person = {
//     name: "Joe",
//     age: 33,
// }
// zoo.call(person, "my name is", 2)
// // կտպի my name is Joe2

// // այսինքն երկրորդ մեխանիզմը թե ինչպես կարելիյա որոշել ֆունկցիայի this-ը ինչ է դա նենց է որ էտ ֆունկցիաին կարող ենք call ֆունկցիայով կանչենք և կոնկրետ որպես առաջին պարամետր ասենք էս object-ը թող լինի քո this-ը և իրա մնացած պարամետրները 



// // 11.
// // երկրորդ ֆունկցիա կա որը աշխատում է գրեթե նույն ձևի ինչպես որ call-ը որը կոչվում է apply(դիմել) էլի առաջին պարամետրը կլինի իրա this արժեքը բայց իրա մնացած պարամետրները մենք փոխանցում ենք զանգվածով ոչ թե առանձին այսինքն քան թե սենց "my name is", 2  փոխանցենք փոխանցում ենք այսպես ["my name is", 2] 
// // վերջում նույն բանն է ստացվում էս "my name is"-ը գնումա մտնումա txt-ի մեջ,այս 2-ը գնումա մտնումա x-ի մեջ
// // երկուսն էլ աշխատում են գրեթե նույն ձևի ուղղակի էլի եմ ասում մեկը առանձին եք ստորակետներով եք առանձին պաս տալի պարամետրները իսկ  apply-ի դեպքում մի հատ զանգված որի արժեքները գնում են մտնում են որպես արժեքները այս ֆունկցիայի այս պարամետրների(txt, x)

// function zoo(txt, x) {
//     alert(txt + " " + this.name)
// }

// let person = {
//     name: "Joe",
//     age:33
// }

// zoo.call(person, "my name is", 2);
// zoo.apply(person, ["my name is", 2])






// // 12.
// // բացի call և apply անելուց մենք կարող ենք անենք հետևյալը կարող ենք zoo-ին անենք dat bind և տանք իրան ինչ որ content ինչ որ this object օրինակ person
// // այս bind-ը վերաադարձնումա մի հատ նոր ֆունկցիա որը ես գցում եմ էս փոփոխականի մեջ հիմա էս ֆունկցիան ինչ է էս ֆունկցիան պատկերացրեք նույն է իչպես որ էս ֆունկցիան(zoo-ն) բայց իրա this-ը արդեն նշանակված է իրա this-ը արդեն person է

// function zoo(txt, x) {
//     alert(txt + " " + this.name)
// }
// let person = {
//     name: "Joe",
//     age: 33
// }
// let f = zoo.bind(person);


// // հիմա ապագայում եթե ես ընդամենը կանչեմ f-ը ինչ որ մի տեքստով և ինչ որ մի թվով , այս տեքստը կգնա կմտնի txt-ի մեջ, այս թիվը կգնա կմտնի x-ի մեջ իսկ իրա this-ը կլինի այսա (person)-ը

// function zoo(txt, x) {
//     alert(txt + " " + this.name + x)
// }
// let person = {
//     name: "Joe",
//     age: 33
// }

// let f = zoo.bind(person);
// f("hello world", 5)

// // կտպի hello world Joe5

// // որը նույն է
// zoo.bind(person)("hello world", 5) 
// // կամ 
// zoo.bind(person, "hello world", 5)() 

// // / Ի տարբերություն call() և apply() մեթոդների, bind() մեթոդը անմիջապես չի կատարում ֆունկցիան: Այն պարզապես վերադարձնում է ֆունկցիայի նոր տարբերակը, որի վրա սահմանվում է this արժեքը:


/* 

// // այս ֆունկցիաները(bind, call, apply) ինչ որ մի ֆունկցիայի վրա կանչելուց հենց էտ պահին կանչելու ժամանակ ենք ասում ուզում ենք որ քո this-ը լինի այս object-ը
function zoo(txt, x) {
    alert(txt + " " + this.name + x)
}
let person = {
    name: "Joe",
    age: 33
}

zoo.bind(person)("barev", 6) 
zoo("barev", 5)

zoo.call(person, "barev", 4);
zoo("barev", 3)

zoo.apply(person, ["barev", 2])
zoo("barev", 1)

// // կտպի barev Joe6 հետո barev 5 հետո barev Joe4 հետո barev 3 հետո barev Joe2 հետո barev 1

*/






// // 13. 
// // եկեք փորձենք bind-ը մենք ինքնուրույն գրենք որ ավելի լավ հասկանանք bind-ը ինչպես է աշխատում 

// 1 //
// // ստուգենք թե իրական bind-ը ինչպեսա աշխատում որպեսզի սխալներ թույլ չտանք մեր կոդի մեջ
// zoo.bind(person,"barev sjdh", 10)()
// zoo.bind(person)("barev sjdh", 10)
// zoo.bind(person, "hello world", 9)("barev sjdh", 10)
// zoo.bind(person)()


// 2 //
// function zoo(txt, x) {
//     alert(txt + " " + this.name + x)
// }

// let person = {
//     name: "Joe",
//     age: 33
// }

// // bind-ը առաջի փակագծի մեջի արժեքնա համարում առաջնահերթ իսկ այս գրածը երկրորդ փակագծի
// // իրա գրածը մի քիչ ուղղումով
// function bin(func, context, ...args ) {
//    return function(...args) {
//         return func.apply(context, args)
//     }
//  }


// // վերագրելով 
// const f = bind(zoo, person);
// f("hello world", 9);
// // կտպի hello world Joe9

// // առանց վերագրել
// bin(zoo, person, "hello world", 9)("barev sjdh", 11)
// // կտպի hello world Joe9
// bin(zoo, person)()


// 3 //
// function zoo(txt, x) {
//     alert(txt + " " + this.name + x)
// }

// let person = {
//     name: "Joe",
//     age: 33
// }

// // այս կոդը աշխատումա այնպես ինչպես որ աշխատում է bind ֆունկցիան 
// function bin(func, context, ...args ) {
//     return function(...arg) {
//                 function rr() {
//                     if(args !== undefined) {
//                         return args
//                     } else {
//                         return arg
//                     }
//                 }
//             return func.apply(context, rr())
//             }
// }

// // վերագրելով 
// const f = bind(zoo, person);
// f("hello world", 9);
// // կտպի hello world Joe9

// // առանց վերագրել
// bin(zoo, person, "hello world", 9)("barev sjdh", 11)
// // կտպի hello world Joe9



// // // ինչը պարզ չի եղել // // //
// 1 //
// // // ինչա վերադրձնում և փակագիծները ինչա նշանակում

// // bin ֆունկցիան վերադարձնումա որ կանչում ենք վերդարձնումա ոչ թե func.apply(context, args) այլ 
// // վերադարձնումա function(...args) {
// //                     return func.apply(context, args)
// //                  }
// // 
// //  առաջի փակագիծները նշանակումա մենք կանչում ենք bin ֆունկցիան, իսկ երկրորդ փակագիծները նշանակումա մենք կանչում ենք այն ֆունկցիան որը վերադարձնումա bin ֆունկցիան հետևաբար առաջի փակագիծների մեջի արժեքները որ տալիսենք ստանում ենք bin ֆունկցիայից իսկ երկրորդ փակագիծների մեջի տված արժեքները մենք ստանում ենք bin ֆունկցիայի վերադարձրած ֆունկցիայից քանի որ երկրորդ փակագիծները նշանակումա որ մենք կանչում ենք bin ֆունկցիային տված ֆունկցիան


// 2 //
// // // եթե երկու տեղիցենք արժեք ստանում մեր գրած bind-ը և իրական bind-ը որնա արաջնահերթ համարում

// // (մեր գրած bind ֆունկցիան) եթե bind ֆունկցիային տված ֆունկցիայից և օբյեկտից բացի մնացած արժեքները ստանում ենք և bind ֆունկցիայից և bind ֆունկցիային տված ֆունկցիայից ապա առաջնահերթ է համարվում bind ֆունկցիային տված ֆունկցիայից ստացած արժեքը քանի որ եթե իր սահմանում փոփոխականը հայտարարված չի իր արժեքը վերցնում է մի հատ բարձր սահմանից փոփոխականի օրենքին համաձայն
// // (արդեն գործող bind ֆունկցիան) եթե bind ֆունկցիային տված ֆունկցիայից և օբյեկտից բացի մնացած արժեքները ստանում ենք և bind ֆունկցիայից և bind ֆունկցիային տված ֆունկցիայից ապա առաջնահերթ է համարվում bind ֆունկցիայից ստացած արժեքը քանի որ կոդը լոգիական այդպես է գրված


// 3 //
// // // ինչ սխալներ կարա բերի

// // և եթե երկու ստեղիցե արժեք չի ստանում բայց bind ֆունկցիայի տված ֆունկցիայի մեջ օգտագործվումա տպում undefined այսինքն կա բայց սահմանված չի
// // իսկ եթե սխալա ստանում ասենք առանց spread արած կոդը չի աշխատում
// // function bind(func, context) {
// //   return function() {
// //        return func.apply(context, args)
// //    }
// // }


// 4 //
// // // հիշելու համար spread օպերատորը
// function max(x, y, ...val) {
//     alert(val)
// }
// let a = [40, 50, 7, 8, 20]
// max(...a); // max(40, 50, 7, 8, 20)





// // 14.
// 1 //
// մնաց մի հատ կարևոր դետալ էլ երբ է այսպես ասած this-ը հանդիպում 

// function Person () {
// }
// new Person()

// new Person() նշանակումա որ մենք ուզում ենք օգտագործենք այս ֆունկցիան object ստեղծելու համար այսինքն ինչ է ստացվում որ երբ որ մենք new-ով ենք կանչում ինչ որ մի ֆունկցիա ինքը իր մեջ ստեղծումա մի հատ նոր this

// 2 //
// // պատկերացրեք new-ն տակից ոնցոր սենց մի բանա անում ստեղծումա մի հատ նոր object վերագրումա this-ի մեջ և վերջում վերադարձնումա էտ this-ը 
// function Person () {
//   this = {}
  
//   return this
// }

// new Person()

// օրինակ //
// // հետևաբար մենք կարող ենք անենք 
// function Person() {
//     this.name = "Joe";
//     this.age = 6;
// }
// const a = new Person()

// alert(a.name)
// // կտպի Joe

// // և ինչ է ստացվում և էս ամբողջը վերադարձնում է էտ ստեղծված object-ը որը մենք հիմա գցում ենք a-ի մեջ այսինքն եթե մենք alert անենք a.name մենք կստանանք joe 


// 3 //
// սա կոչվում է function constructor(ֆունկցիա կառուցող) այսինքն ինքը ֆունկցիա է որը մենք օգտագործում ենք object ստեղծելու համար


// 4 //
// // կրկնել

// // սա սովորական ֆունկցիա է բայց քանի որ մենք օգտագործելու ենք իրան սովորական object ստեղծելու համար հիմնականում որպես կոնվեցիա մենք մեծատառով ենք իրան ստեղծում դա անպայման չի դա ուղղակի ցանկանալիա 
// // հիմա երբ որ մենք new-ով ենք էտ ֆունկցիան կանչում ինքը իր մեջ ստեղծում է մի հատ object որը իրա this-ի մեջ է ստեղծվում այսինքն իրա this-ը լինում է նոր դատարկ մի object
// // էտ դատարկ մի object-ի մեջ որը this-ն է մենք գցում ենք name և age-ը և էտ դատարկ object-ը վերադարնում է կամ return է արվում էտ ֆունկցիայից ավտոմատիկ, մենք կարող ենք անենք return this բայց new-ն տակից նույնը անումա մեկա 

// function Person() {
//     this.name = "Joe";
//     this.age = 6;
//     return this;
// }

// const a = new Person()
// alert(a.name)

// // այսինքն new-ն ինչա անում ինքը this ստեղծումա մի հատ նոր object հետո վերջում երբ որ ֆունկցիան ավարտվում է վերադարձնում է էտ նոր object-ը և մենք ստեղ ընթացքում կարող ենք էտ object-ը ոնցոր փոխենք ինչ որ արժեքներ ավելացնենք և այլն և այլն և էտ ամենը քանի որ վերադառնում է մենք գցում ենք մի հատ փոփոխականի մեջ 

// // հիմա էս a-ը հղվածը էտ object-ը որը ստեղծվել է էս ֆունկցիայով էս function constructor-ով(function կառուցողով)  հետևաբար հիմա a.name կտա այս joe-ն որը մենք ֆունկցիայի մեջ ստեղծեցինք 





// // 15.
// // ինչ է ստացվում որ this-ը օգտագործվում է մի քանի տարբեր տարբերակներով
// 1.
// երբ որ մենք կետով ենք կանչում որևէ ֆունկցիա էտ կետի ձախ կողմի արժեքը դառնումա իրա this-ը
// let a = {
//     f: function() {
//         alert(this)
//     }
// }
// a.f()

// սա նշանակումա որ այ էս f-ի this-ը կլինի a-ը



// 2.
// եթե մենք ուղղակի ունենք մի հատ առանձին ֆունկցիա որը չենք կանչում որպես կցած ինչ որ բանին այլ ուղղակի իրան կանչում ենք և alert ենք անում իրա this-ը
// սովորական այսինքն առանց strict mode-ի javascript-ում եթե աշխատացնենք իրա this-ը կլինի window object-ը բրաուզերի մեջ 
// եթե մենք աշխատացնենք strict mode-ում(խիստ ռեժիմում)  այ սենց "use strict" javascript-ը մի թեթև ուրիշ է աշխատացնում այսինքն էս use strict-ը մենք ասում ենք բրաուզերին, բրաուզեր ջան երբ որ աշխատացնես էս կոդը աշխատացրու մի քիչ ուրիշ ձևով strick ձևով այսպես ասած 
// էտ ժամանակ իրա this-ը կլինի undefined 

// "use strict"

// function a() {
//     alert(this)
// }

// a()
// կտպի undefined 



// 3․
// 1 //
// եթե մենք ունենք ինչ որ մի ֆունկցիա և ուզում ենք իրեն կանչենք այնպես որ իրա this-լինի ինչ որ կոնկրետ object
// մենք կարող ենք ֆունկցիայի վրա աշխատացնել call ֆունկցիան և տանք այն object-ը որը ուզում ենք լինի իրա this-ը

// function a(z, d, e) {
//     alert(this)
// }

// const b = {
//     name: "Joe"
// }

// a.call(b, 1, 2, 3)

// ինչ է ստացվում որ հիմա a-ի this-ը կլինի b object-ը 

// 2 //
// նույնը կարող ենք անել apply-ով ուղղակի տարբերությունը call-ի և apply-ի նա է որ մնացած արժեքները որը մենք ուզում ենք փոխանցենք apply-ին, apply-ով դա զանգված են որպես գալի իսկ call-ի ժամանակ փոխանցում ենք որպես առանձին արժեքներ
// function a(z, d, e) {
//     alert(this)
// }

// const b = {
//     name: "Joe"
// }

// a.apply(b, [1, 2, 3])


// 4.
// function a(z, d, e) {
//     alert(this.name)
// }

// const b = {
//     name: "Joe"
// }

// a.bind(b)()

// // Ի տարբերություն call() և apply() մեթոդների, bind() մեթոդը անմիջապես չի կատարում ֆունկցիան: Այն պարզապես վերադարձնում է ֆունկցիա, որի վրա սահմանվում է this արժեքը:(որը եթե կանչենք կվերադարձնի return func.apply(context, rr()))

// // bind ֆունկցիայի լոգիկան
// function bind(func, context, ...args ) {
//     return function(...arg) {
//         function rrr() {
//             if(args !== undefined) {
//                return args
//             } else {
//                return arg
//             }
//         }
//         return func.apply(context, rrr())
//     }
// }


// 5.
// եթե մենք ունենք ֆունկցիա և իրեն կանչում ենք new-ով իրա this-ը դառնում է մի հատ նոր object և էտ ֆունկցիան վերադարձնում է էտ նույն object-ը
// function zoo() {
//   this = {}

//   return this
// }

// const a = new zoo()
// alert(a)
// կտպի դատարկ պատուհան