
// "use strick"

// 1
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(person.name)
//     }
// }

// person.printName()


// 2
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(person.name)
//     }
// }

// let p = person;
// person = 8;

// p.printName();


// 3
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }

// let p = person;
// person = 8;

// p.printName();

// // this նշանակումա այս, 
// // this-ը ինչ է ինքը հղում է դեպի են object-ին որի մեջ ֆունկցիան աշխատում է



// // 4
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// };

// // հիմա եթե մենք փոխենք հղումը
// let p = person
// person = 9


// person.printName()
// // սա նշանակում է որ ես ուզում եմ աշխատացնեմ այս անունը էս object-ի մեջ հետևաբար այս ֆունկցիայի ներքին this-ը կլինի
// // հենց սա հենց էս object-ը այսինքն this-ը կլինի դա





// // 5
// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// };

// let p = person
// person = 9

// p.printName()
// // էս ժամանակ այս ֆունկցիան կունենա որպես իր this արժեքը սա
// // այսինքն նույնիսկ եթե մենք person-ը հիմա փոխենք դարձնենք ասենք թե 9-ը սա կշարունակի աշխատել


// function zoo() {
//     alert(this.name)
// }
// zoo()

// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }
// person.foo = zoo

// let person2 = {
//     name: "Mike",
//     age: 39
// }

// person2.foo = zoo




// էս պահին մենք սովորելենք ոնցոր երկու օրենք թե ինչպես կարելիյա որոշել ֆունկցիայի this-ը ինչ է 

// եթե ֆունկցիաին մենք կանչում որպես ֆունկցիան կցած ուրիշ object-ի այսինքն ինչ որ object կետ էտ ֆունկցիան էտ ֆունկցիայի this-ը կլինի էտ object-ը այսինքն եթե ստեղ մենք անում ենք 
// person2.foo()  this-ը այս ֆունկցիայի կլինի այէս object-ը(person2) այսինքն կետի ձախ կողմից

// եթե մենք ստեղ կանչում ենք ուղակի ստեղծում ենք մի հատ ֆունկցիա որը ուղակի առանձին իրեն կանչում ենք իրա this-ը կլինի գլոբալ object-ը որը բրաուզերի մեջ դա window object-ն է օկեյ 
// կարևոր է ասել որ ուրեմն լիքը մարդ սխալներ են թույլ տվել էսրա պատճառով որովհետև ստեղծել են մի հատ առանձին ֆունկցիա և հետո կանչել են ենթադրելով որ this-ը կլինի ինչ որ հատուկ բան մեկե ստացվելա որ this-ը գլոբալ փոփոխականն է և լիքը լոգիկայի սխալներ են թույլ տվել
// function zoo() {
//     alert(this.name)
// }
// zoo()

// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }
// person.foo = zoo

// let person2 = {
//     name: "Mike",
//     age: 39
// }

// person2.foo = zoo
// person2.foo()




// դրա համար ուրեմն ստեղծվել է մի հատ այսպես ասած strick mode use strick ներողություն
// եթե մենք այս տեքստը  ամենա վերևում գրենք մեր javascript-ի "use strick" , մեր javascript-ը կաշխատի մի քիչ ուրիշ, մի քիչ ուրիշ ասելով էս this-ը եթե մենք փորձենք աշխատացնել սովորական  ֆունկցիայի մեջ որը կցած չի կամ չի աշխատում որևէ կոնկրետ object-ի մեջ իրա this-ը կլինի undefined այսինքն հիմա եթե մենք սենց անենք ու print անենք this-ը

// function zoo() {
//     alert(this.name)
// }
// zoo()

// let person = {
//     name: "Joe",
//     age: 33,
//     printName: function() {
//         alert(this.name)
//     }
// }
// person.foo = zoo

// let person2 = {
//     name: "Mike",
//     age: 39
// }

// person2.foo = zoo
// person2.foo()


// հիմանականում պետք է հասկանալ որ եթե դուք ուղակի առանձին ֆունկցիա ստեղծեք և իրան կանչեք իրա this-ը կլինի undefined բայց էտ նույն ֆունկցիան եթե մենք կպցնենք ինչ որ մի object-ին և հետո ըստ էտ object-ի կանչենք իրեն այսինքն կանչենք նենց որպեսզի ինքը աշխատի էտ object-ի մեջ էտ ժամանակ իրա this-ը կլինի էտ object-ը որին մենք կարող ենք անենք this.name օրինակ էս պարագայում դա կլինի Mike այսինքն եթե ֆունկցիան կցածա մի հատ object-ին ու մենք էտ object-ի միջոցով կանչում ենք էտ ֆունկցիաին էտ ֆունկցիայի this-ը դարնումա էտ object-ը

// այսինքն եթե ֆունկցիան կցածա մի հատ object-ի ու մենք էտ 




// // 10
// function zoo() {
//     alert(this.name)
// }


// let person = {
//     name: "Joe",
//     age: 33,
// }

// zoo.call()

// մենք կարող ենք բացի նրանից որ կարողենք կպացնենք zoo-ն person-ին և ըստ էտ person-ի միջոցով կետով աշխատացնենք էտ ֆունկցիաին և հետևաբար իրա this-ը կդարնա էտ person object-ը բացի դրանից կարող ենք անենք սենց 

// հիշեք որ ֆունկցիաները javascript-ում object-ներ են հետևաբար ֆունկցիաները կարող են ունենալ իրանց մեջ ուրիշ ֆունկցիաներ խնդրեմ օրինակ call 
// այսինքն ինչ է ստացվում որ մենք վերցնում ենք էս ֆունկցիան կանչում ենք call ֆունկցիան որրը իրան կցած է
// call նշանակում է կանչիր
// call-ին մենք փոխանցում ենք որպես առաջին արժեք object  context object-ը դա իրա this-ն է  այսինքն մենք որպես առաջին պարամետր ստեղ կարող ենք որոշենք իրա this-ը ինչա լինելու
// եկեք իրա this-ը թող լինի person

// function zoo() {
//     alert(this.name)
// }

// let person = {
//     name: "Joe",
//     age: 33,
// }

// zoo.call(person)
// // // կտպի joe

// այսինքն ինչ է ստացվում որ մենք կարող ենք ինչ որ մի ֆունկցիան կանչելուց հենց էտ պահին կանչելու ժամանակ ասենք ես ուզում եմ որ քո this-ը լինի այս object-ը իսկ դա ինչպես կարող ենք անենք call-ով
// հիմա դրանից հետո եթե մեր zoo-ն վերցնումա ինչ որ մի պարամետր ասենք թե txt որը ասենք գումարում ենք ստեղ ինչ որ սենց բան ենք անում դա call-ում կլինի մնացած պարամետրները այսինքն եթե մենք ստեղ տանք "my name is" ինչ որ սենց մի բան  ինչ կստացվի որ 
// առաջին պարամետրը call-ի դա են object-ն է որը կլինի իրա this-ը իսկ մնացած պարամետրները են պարամետրներն են որոնք որ կգնան կմտնեն իրա մեջ

// function zoo(txt) {
//     alert(this.name)
// }

// let person = {
//     name: "Joe",
//     age: 33,
// }

// zoo.call(person, "my name is")
// // // կտպի joe



// այսինքն եթե ստեղ նաև դնեմ 2 դա կանցնի որպես երկրորդը x ասենք թե 
// function zoo(txt, x) {
//     alert(txt + " " + this.name)
// }

// let person = {
//     name: "Joe",
//     age: 33,
// }

// zoo.call(person, "my name is", 2)
// այսինքն երկրորդ մեխանօզմը թե ինչպես կարելիյա որոշել ֆունկցիայի this-ը ինչ է դա նենց է որ էտ ֆունկցիաին կարող ենք call ֆունկցիայով կանչենք և կոնկրետ որպես առաջին պարամետր ասենք էս object-ը թող լինի քօ this-ը և իրա մնացած պարամետրները 


// երկրորդ ֆունկցիա կա որը աշխատում է գրեթե նույն ձևի ինչպես որ call-ը որը կոչվում է apply էլի առաջին պարամետրը կլինի իրա this արժեքը բայց իրա մնացած պարամետրները մենք փոխանցում ենք զանգվածով ոչ թե առանձին այսինքն քան թե սենց "my name is", 2  փոխանցենք փոխանցում ենք այսպես ["my name is", 2] 
// վերջում նույն բանն է ստացվում էս "my name is"-ը գնումա մտնումա txt-ի մեջ,այս 2-ը գնումա մտնումա x-ի մեջ երկուսն էլ աշխատում են գրեթե նույն ձևի ուղակի էլի եմ ասում մեկը առանձին եք ստորակետներով եք առանձին պաս տալի պարամետրները իսկ  apply-ի դեպքում մի հատ զանգված որի արժեքները գնում են մտնում են որպես արժեքները այս ֆունկցիայի այս պարամետրների(txt, x)

// function zoo(txt, x) {
//     alert(txt + " " + this.name)
// }

// let person = {
//     name: "Joe",
//     age:33
// }

// // zoo.call(person, "my name is", 2);
// zoo.apply(person, ["my name is", 2])






// բացի call և apple անելուց մենք կարող ենք անենք հետևյալը կարող ենք zoo-ին անենք dat bind և տանք իրան ինչ որ content ինչ որ this object person օրինակ սա
// այս bind-ը վերաադարձնումա մի հատ նոր ֆունկցիա որը ես քցում եմ էս փոփոխականի մեջ հիմա էս ֆունկցիան ինչ է էս ֆունկցիան պատկերացրեք նույն է իչպես որ էս ֆունկցիան(zoo-ն) բայց իրա this-ը արդեն նշանակված է իրա this-ը արդեն person  է
// function zoo(txt, x) {
//     alert(txt + " " + this.name)
// }

// let person = {
//     name: "Joe",
//     age: 33
// }

// let f = zoo.bind(person);





// հիմա ապագայում եթե ես ընդամենը կանչեմ f-ը ինչ որ մի տեքստով և ինչ որ մի թվով , այս տեքստը կգնա կմտնի txt-ի մեջ, այս թիվը կգնա կմտնի x-ի մեջ իսկ իրա this-ը կլինի այսա(person)-ը
// function zoo(txt, x) {
//     alert(txt + " " + this.name)
// }

// let person = {
//     name: "Joe",
//     age: 33
// }

// let f = zoo.bind(person);
// f("hello world", 5)
// // կտպի hello world joe






// եկեք փորձենք bind-ը մենք ինքնուրույն գրենք որ ավելի լավ հասկանանք bind-ը ինչպես է աշխատում 

// function zoo(txt, x) {
//     alert(txt + " " + this.name)
// }

// let person = {
//     name: "Joe",
//     age: 33
// }

// function bind(func, context) {
//     return function(...args) {
//         return func.apply(context, args)
//     }
// }

// const f = bind(zoo, person);
// f("hello world", 9);

// // կտպի hello world Joe






// մնաց մի հաատ կարևոր դետալ էլ երբ է this-ը այսպես ասած հանդիպում 

// function Person () {

// }

// new Person()
// new Person() նշանակումա որ մենք ուզում ենք օգտագործենք այս ֆունկցիան object ստեղծելու համար այսինքն ինչ է ստացվում որ երբ որ մենք new-ով ենք կանչում ինչ որ մի ֆունկցիա ինքը իր մեջ ստեղծումա մի հատ նոր this


// պատկերացրեք ինքը մի հատ սենց բանա անում ինքը տակից ոնցոր սենց մի հատ բանա անում ստեղծումա մի հատ նոր object էս new-ն 
// function Person () {
//   this = {}
// }

// new Person()


// հետևաբար մենք կարող ենք անենք 
// function Person() {
//     this.name = "Joe";
//     this.age = 6;
// }

// const a = new Person()
// և ինչ է ստացվում և էս ամբողջը վերադարձնում է էտ ստեղծված object-ը որը մենք հիմա քցում ենք a-ի մեջ հիմա այսինքն
// եթե մենք alert անենք a.name մենք կստանանք joe խնդրեմ

// function Person() {
//     this.name = "Joe";
//     this.age = 6;
// }

// const a = new Person()
// alert(a․name)

// սա կոչվում է function cnstrackter այսինքն ինքը ֆունկցիա է որը մենք օգտագործում ենք object ստեղծելու համար





// մի հատել բացատրեմ որպեսզի չխճճվեք նայեք

// սա սովորական ֆունկցիա է բայց քանի որ մենք օգտագործելու ենք իրան սովորական object ստեղծելու համար հիմնականում որպես կոնվեցիա մենք մեծատառով ենք իրան ստեղծում դա անպայման չի դա ուղակի ցանկալիյա 
// հիմա երբ որ մենք new-ով ենք էտ ֆունկցիան կանչում ինքը իր մեջ ստեղծում է մի հատ object որը իրա this-ի մեջ է ստեղծվում այսինքն իրա this-ը լինում է նոր դատարկ մի object
// էտ դատարկ մի object-ի մեջ որը this-ն է մենք քցում ենք name և age-ը և էտ դատարկ object-ը վերադարնում է կամ return է արվում էտ ֆունկցիայից ավտոմատիկ մենք պետք չի մենք կարող ենք անենք return this բայց ինքը տակից նույնը անումա մեկա new-ն 

// function Person() {
//     this.name = "Joe";
//     this.age = 6;
//     return this;
// }

// const a = new Person()
// alert(a.name)

// այսինքն new-ն ինչա անում ինքը this ստեղծումա մի հատ նոր object հետո վերջում երբ որ ֆունկցիան ավարտվում է վերադարձնում է էտ նոր object-ը և մենք ստեղ ընթացքում կարող ենք էտ object-ը ոնցոր փոխենք ինչ որ արժեքներ ավելացնենք և այլն և այլն և էտ ամենը քանի որ վերադառնում է մենք քցում ենք մի հատ փոփոխականի մեջ 


// հիմա էս a-ը հղվածը էտ object-ը որը ստեղծվել է էս ֆունկցիայով էս function constrackter-ով  function կառուցողով  հետևաբար հիմա a.name կտա այս joe-ն որը մենք ստեղ ստեղծեցինք 







// այսինքն ինչ է ստացվում որ this-ը օգտագործվում է մի քանի տարբեր տարբերակներով
// 1.
// let a = {
//     f: function() {
//         alert(this)
//     }
// }
// a.f()

// սա նշանակումա որ այէս f-ի this-ը կլինի այ a-ը
// այսինքն երբ որ մենք կետով ենք կանչում որևէ ֆունկցիա էտ կետի ձախ կողմի արժեքը դառնումա իրա this-ը
// էտ արաջին

// 2.?
// երկրորդը
// եթե մենք ուղակի ունենք մի հատ առանձին ֆունկցիա որը չենք կանչում որպես կցած ինչ որ բանին այլ ուղակի իրան կանչում ենք և alert ենք անում իրա this-ը
// սովորական այսինքն առանց strick mode-ի javascript-ում եթե աշխատացնենք իրա this-ը կլինի window object-ը բրաուզերի մեջ?? 
// եթե մենք աշխատացնենք use strick  այ սենց "use strick" javascript-ը մի թեթև ուրիշ է աշխատացնում այսինքն էս use strickt-ը մենք ասում ենք բրաուզերին, բրաուզեր ջան երբ որ աշխատացնես էս կոդը աշխատացրու մի քիչ ուրիշ ձևով strick ձևով այսպես ասած 
// էտ ժամանակ իրա this-ը կլինի undefined խնդրեմ undefined

// "use strick"

// fucntion a() {
//     alert(this)
// }

// a()



// 3