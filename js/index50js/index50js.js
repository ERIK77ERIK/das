// // 1
// // ծրագրաորման ժամանակ մենք ունենք շատ տարբերակներ թե ինչպես կարող ենք դասաորենք մեր կոդը, որտեղ դնենք մեր արժեքները, որտեղ դնենք մեր ֆունկցիաները և այլն
// // գոյություն ունի object oriented programming որը մի մոտեցում է թե ինչպես կարելի է դասաորել մեր կոդը

// // որպեսզի լավ հասկանանք object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում) եկեք նախ և առաջ ուսումնասիրենք մի օրինակ
// 1.1
// let name = "Joe";
// let lastName = "Jaspers";
// let age = 55;
// let friends = [];
// let name2 = "Mike";
// let lastName2 = "Jackson";
// let age2 = 55;
// let friends2 = [];

// function getFullName(name, lastName) {
//     return name + " " + lastName;
// }


// 1.2
// const person1 = {
//     name: "Joe",
//     lastName: "Jaspers",
//     age: 55,
//     friends: []
// }

// const person2 = {
//     name: "Mike",
//     lastName: "Jackson",
//     age: 66,
//     friends: [person1]
// }


// function getFullName(name, lastName) {
//     return name + " " + lastName;
// }

// // սա բացի նրանից որ ավելի հեշտ է կարդացվում և ավելի պարզ է, որ էս ամենը(object-ի մեջի տվյալները) կապ ունի իրար հետ և խմբաորվածա մի object-ի մեջ իր հետ աշխատելնել է հեշտ 
// // օրինակ եթե մենք ուզում ենք ավելացնենք Joe-ին որպես ընկեր Mike-ին մենք ընդամենը կարող ենք անենք այսպես const person2 = { friends: [person1] };


// 1.3
// // բացի նրանից որ մենք կարող ենք խմբաորել ինֆորմացիան մենք նաև կարող ենք կցենք այս object-ներին ֆունկցիաներ որոնք որ կապ ունեն իրենց հետ
// const person1 = {
//     name: "Joe",
//     lastName: "Jaspers",
//     age: 55,
//     friends: [],
//     getFullName: function () {
//        return this.name + " " + this.lastName;
//     }
// }

// const person2 = {
//     name: "Mike",
//     lastName: "Jackson",
//     age: 66,
//     friends: [],
//     getFullName: function () {
//        return this.name + " " + this.lastName;
//     }
// }

// person1.getFullName()

// // այս տարբերակում երբ որ մենք կպցնում ենք getFullName ֆունկցիան հենց object-ին էտ getFullName-ը արդեն գիտի անունը ինչ է this-ով ինքը կարող է արդեն գտնի անուն էլ ազգանունն էլ հետևաբար ինքը արդեն գիտի անունը և ազգանունը և իրեն արդեն պարամետր փոխանցել պետք չի
// // այսինքն հիմա եթե ես ուզենամ ստանամ այս object-ի ամբողջ անունը ես ընդամենը կարող եմ ասեմ person1.getFullName()





// // 2
// const person1 = {
//     name: "Joe",
//     lastName: "Jaspers",
//     age: 55,
//     friends: [],
//     getFullName(name, lastName) {
//         return this.name + " " + this.lastName;
//     }
// }

// const person2 = {
//     name: "Mike",
//     lastName: "Jackson",
//     age: 66,
//     friends: [],
//     getFullName() {
//         return this.name + " " + this.lastName;
//     }
// }


// // object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում)-ը առաջարկում է հետևյալը որ նախ մենք կարող ենք նկարագրենք բաները(բառից բուն իմաստով բան ցանկացած բան թե դա մարդա, թե դա փոստա, թե դա մեքենայա, թե դա փամփուշտա), ցանկացած բան որպես object
// // այսինքն մենք ունենում ենք լիքը տարբեր object-ներ, ամեն object-ը ունի իր մեջ ամբողջ ինֆորմացիան էտ բանի մասին բացի դրանից մենք նաև կարող ենք ավելացնենք էտ object-ներին ֆունկցիաներ որոնք որ կապ ունեն էտ բանի հետ,այսինքն որոնք մեզ հնարաորություն կտան աշխատել էտ բանի հետ



// // 3
// // member և mefid
// // արժեքները որոնք որ կցած են object-ին կոչվում են member 
// // ֆունկցիաները որոնք որ կցած են object-ին կոչվում են mefid

////// member-ները դա են բանալիներն են որոնք որ հղում են դեպի արժեք
////// mefid-ները դա են բանալիներն են որոնք որ հղում են դեպի ֆունկցիա

// // ինչու արժի էս տիպի բաները իմանալ դե մենք արդեն գիտեյնք ֆունկցիան ինչա արդեն գիտեյնք բանալին ինչա ումա պետք իմանալ mefid և member որովհետև խոսակցության մեջ երբ որ տեխնիկական ինչ որ խոսակցություն է գնում և ասում են օրինակ object-ի member-ը կամ object-ի mefid-ը որ ուղղակի հասկանաք ինչի մասինա խոսքը 






// // 4
// // 4.1
// // ինչ խնդիրներ կարող է լինել

// const person1 = {
//     name: "Joe",
//     lastName: "Jaspers",
//     age: 55,
//     friends: [],
//     getFullName(name, lastName) {
//         return this.name + " " + this.lastName;
//     }
// }

// const person2 = {
//     name: "Mike",
//     lastName: "Jackson",
//     age: 66,
//     friends: [],
//     getFullName() {
//         return this.name + " " + this.lastName;
//     }
// }


// // այստեղ ունենք երկու օրինակ մարդու պատկերացրեք բայց երկու օրինակի տեղը մենք ունենայնք 50 կամ 100 կամ 1000 անընդհատ մենք պետք է ստեղծենք մի մարդ(object) դե ամեն ստեղծելու ժամանակ մենք պետք է լրացնենք իր բլոր ինֆորմացիան, իրա բոլոր ֆունկցիանները(էս օրինակում ընդամենը ունենք մի ֆունկցիա բայց պատկերացրեք կարող ենք ունենանք շատ) և ինֆորմացիան(հիմա ունենք անուն, ազգանուն, տարիք, ընկերները բայց իրականում կարող ենք ունենալ շատ ավելի շատ ինֆորմացիա)

// // այսինքն ամեն անգամ երբ մենք ուզում ենք ստեղծենք object սենց մարդ object ամեն անգամ մենք պետք է հիշենք մարդը ինչ ֆունկցիաներ պետք է ունենա ինչ բանալի ների անուններ պետք է ունենա(այսինքն ինչ member-ներ և mefid-ներ ինքը պետք է ունենա) որպեսզի մենք ճիշտ լրացնենք և մեկը մեկի ինքը նմանվի մնացած մեր person object-ներին որպեսզի օրնակ մենք loop-ով պտտվենք մեր բոլոր object-ներով և ինչ որ գործողություն անենք բոլորը աշխատեն նույն ձևի
// // բայց օրինակ նոր մարդ object ստեղծելուց շատ հեշտ կարելի է շփոթվել, շատ հեշտ կարելի է օրինակ ստեղ գրել lastname մոռանալ որ մի րոպե ամեն տեղ օգտագործում էինք մեծատառ N  lastName  ստեղ փոքրատառ ենք օգտագործել սա մի խնդիրն է, երկորդը այն է որ մենք պետքա հիշենք բոլոր ֆունկցիաները(mefid-ները) որ մենք պետք է ավելացնենք մեր object-ին այսինքն մենք պետք է օրինակ նույն object-ի ֆունկցիան copy անենք past անենք ստեղ դա էլա խնդիր այսինքն էդքան անգամ հայտարարում ենք առանձին այդ ֆունկցիան այսինքն եթե մենք ինչ որ սխալ գտնենք այս ֆունկցիայի մեջ մենք պետք է գնանք ու բոլոր հատ հատ ամեն տեղ որտեղ որ էտ ֆունկցիան հայտարարել ենք գնանք ձեռքով և շտկենք եթե մենք ուզենանք մարդուն ավելորդ ինչ որ մի ֆունկցիա ավելացնենք հերիք չի որ մենք ավելացնում ենք էտ ֆունկցիաին ստեղ(մի object-ի մեջ) մենք նաև պիտի գնանք և գտնենք ամեն տեղ որպեսզի ոնց որ մենք ստեղծել ենք մարդուն ավելացնենք այդ ֆունկցիան ամեն ստեղծված մարդ object-ի մեջ

// const person3 = {
//     lastname: "Artur"
// }


// // 4.2
// // հիշեցում this-ից

// // դրա համար կարելի է ավելի խելացի ձևով կառուցել object-ներին, են object-ը որը ստեղծվում է ոչ թե մի անգամ այլ անընդհատ էտ տիպի object ստեղծվում է, մենք կարող ենք կառուցենք ֆունկցիաով․

// // function constructor

// function F() {
//     // this = {}
//         this.name = "Joe";
//     // return this
// }

// alert(JSON.stringify(new F()))

// // և հիմանականում երբ որ մենք ստեղծում ենք ֆունկցիաներ որոնց մենք օգտագործել ենք որպես constructor այսինքն object կառուցող հիմնականում էտ տիպի ֆունկցիաները սկսվում են մեծատառով 




// // 4.3
// // այսինքն ինչ է ստացվում որ մենք այ էս տիպի object-ները կարող ենք կառուցենք այսպես

// const person1 = {
//     name: "Joe",
//     lastName: "Jaspers",
//     age: 55,
//     friends: [],
//     getFullName(name, lastName) {
//         return this.name + " " + this.lastName;
//     }
// }

// const person2 = {
//     name: "Mike",
//     lastName: "Jackson",
//     age: 66,
//     friends: [],
//     getFullName() {
//         return this.name + " " + this.lastName;
//     }
// }

// //  ||
// //  \/

// function Person(name, lastName, age) {
//     // this = {}
//     this.name = name,
//     this.lastName = lastName,
//     this.age = age,
//     this.friends = [],
//     this.getFullName = () => {
//         return this.name + " " + this.lastName;
//     }
//     // return this
// }

// const person1 = new Person("Joe", "Jaspers", 55);
// const person2 = new Person("Mike", "Jackson", 66);

// // ասյինքն ստեղծենք մի հատ function constructor ինչպես տեսնում եք մեծատառով է սկսվում որը ընդունում է ինչ որ արժեքներ որով ինքը նախնական կառուցում է մի հատ object և վերդարձնում է մեզ ինչի նախնական որովհետև հետո էս object-ին իհարկե կարող ենք փոխենք օրինակ․

// person1.friends.push(person2);





// // 5
// // անհրաժեշտությունը բացատրությամբ
// // instanceof(օրինակ)

// // 5.1
// // function constructor-ին պատկերացրեք որպես ֆորմա
// // պատկերացրեք կա մի հատ գործարան որտեղ որ կան տարբեր ֆորմաներ կա մարդու ֆորմա, կատվի ֆորմա շան ֆորմա և այլն, և դուք այդ գործարանին ասում եք մի հատ այս մարդու ֆորմաից ստեղծիր ինձ մի հատ մարդ ինքը վերցնումա էտ մարդու ֆորմաից մի հատ սարքումա և վերադարձնումա ստեղծված մարդուն էլիա մարդ պետք խնդիր չկա մի հատ էլ էք ուզում ինքը էլի մի հատ սենց սարքումա և վերադարձնումա նոր մարդուն
// // այսինքն այս person-ը օգտագործեք որպես մի հատ ֆորմա որին կարելի է ամեն կանչելուց ինքը մի հատ սարքումա և վերադարձնումա այդ նոր մարդուն որը մենք վերագրում ենք ինչ որ փոփոխականի մեջ

// // նույնպես մենք կարող ենք ունենալ կատվի ֆորմա 

// function Cat() {
//     this.saySomething = () => {
//         alert("mew");
//     };
// }

// function Person(name, lastName, age) {
//     // this = {}
//     this.name = name,
//     this.lastName = lastName,
//     this.age = age,
//     this.friends = [],
//     this.getFullName = () => {
//         return this.name + " " + this.lastName;
//     }
//     // return this
// }

// const person1 = new Person("Joe", "Jaspers", 55);
// const person2 = new Person("Mike", "Jackson", 66);

// const cat1 = new Cat();


// // 5.2
// function Cat() {
//     this.saySomething = () => {
//         alert("mew");
//     };
// }

// function Person(name, lastName, age) {
//     // this = {}
//     this.name = name,
//     this.lastName = lastName,
//     this.age = age,
//     this.friends = [],
//     this.getFullName = () => {
//         return this.name + " " + this.lastName;
//     }
//     // return this
// }

// const person1 = new Person("Joe", "Jaspers", 55);
// const person2 = new Person("Mike", "Jackson", 66);

// const cat1 = new Cat();

// person1 instanceof Person

// // instanceof նշանակում է օրինակ սա հարցնում է person1-ը օրինակ է Person ֆորմայի այսինքն սա ստեղծված է էս ֆունկցիայից
// alert(person1 instanceof Person);   // true
// alert(person1 instanceof Cat);      // false
// alert(cat1 instanceof Cat);         // true

// // այսինքն ինչ է ստացվում որ հերիք չի որ մենք ունենք այս function constructor-ը որը կարողանումա կառուցել ինչ որ մի object և վերադարձնել իրեն կարելիա ընդունել որպես ֆորմա էտ object-ի որին մենք կարող ենք օգտագործենք որպեսզի ստեղծենք էտ օրինակը հետո ապագայում մենք կարող ենք ասենք էս բանա որ ունենք սրանիցա այսինքն էս object-ը որ ունենք էս object-ի ֆորմայիցա էս function constructor-իցա



// // 6
// // ընդհանուր ամփոփում

// // OOP(object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում))-ի ամբողջ գաղափարը դա նա է որ մենք կոդի մեջ նկարագրում ենք աշխարհը,նկարագրում ենք մարդկանց, նկարագրում ենք մեքենա եթե օրինակ facebook-ն ենք ստեղծում մենք նկարագրում ենք փոստեր, քոմենթներ, մարդկանց, խմբեր, page(էջ) էր և այլն և այլն լիքը տարբեր բաներ այդ ամեն բանա մի object է և քանի որ մենք անընդհատ պետք է ստեղծենք նոր բան, նոր object լավ կլինի որ մենք ունենանք մի ֆորմա մի function constructor օրինակ որից մենք կստեղծենք էտ օրինակները այսինքն մենք կարող ենք ունենանք person ֆորմա(մարդ ֆորմա) որից մենք կստանանք մարդ object-ներ, մենք կարող ենք ունենանք փոստ ֆորմա որից մենք կստանանք տարբեր փոստեր և այլն
// // իսկ երկրորդը որ մենք կարող ենք էտ object-ների մեջ հերիք չի որ կարող ենք փաթեթաորենք ինֆորմացիան որը նկարագրում է այդ object-ին մենք նաև կարող ենք փաթեթաորենք ֆունկցիաները որոնք որ գիտեն էտ object-ի հետ աշխատել ինչ որ գործողություններ անել
// // պատկերացրեք մենք գրեցինք մի խաղ որտեղ որ կա մի հերոս որը գիտի կրակել, մենք կարող ենք ասենք ոչ թե ամեն անգամ ուզում ենք կրակենք գնանք ստեղծենք փամփուշտ գնանք որոշենք իրա x, y-ի կորդինատները և այլն պետք չի մենք ընդամենը էտ հերոսի ․կրակել ֆունկցիան ենք կանչում հետո էտ ․կրակել ֆունկցիան արդեն ներքից քանի որ կպածա մեր հերոսին գիտի  ինչպես կրակել գիտի արդեն մեր հերոսը որտեղա իրա x-ը իրա y-ը իրա լայնությունը իրա բարձրությունը և այլն և այլն և ինքը տակից կարող է ստեղծել փամփուշտը և կրակել


// //  OOP(object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում))-ն շատ տարածված մոտեցում է 
// // դա ինչ որ այսօր սովորեցինք դա ըդհանուր կոնցեպտն է որ պետք է աշխատել object-ներով պետք է նկարագրել ինյֆորմացիան object-ներով, ձևաորել մեր կոդը object-ներով, փաթեթաորել են արժեքները որոնք որ իրար հետ կապ ունեն և ֆունկցիաները որոնք որ իրար հետ կապ ունեն, object-ների մեջ և այդպես գրել, դասաորել մեր կոդը
// // բայց իրականում OOP(object oriented programming(օբյեկտ կողմնորոշված ծրագրավորում))-ը 4 հատ շատ կարևոր դետալներ կամ կոնցեպտներ incapsulation(ինկապսուլյացիան), inheritance(նախատիպային(prototypal և դասական(classical) ժառանգություն)), polymorphizm(պոլիմորֆիզմ) և abstraction(աբստարակցիա)

// // բայց կարևոր է հասկանալ էս կոնցեպտը որ մենք պետք է աշխատենք object-ներով, ձևաորենք մեր կոդը object-ներով, փաթեթաորենք են արժեքները որոնք որ իրար հետ կապ ունեն և ֆունկցիաները որոնք որ իրար հետ կապ ունեն object-ների մեջ և այդպես գրենք, դասաորենք մեր կոդը


